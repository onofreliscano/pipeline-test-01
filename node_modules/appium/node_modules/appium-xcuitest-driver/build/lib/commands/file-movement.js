"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAvailableBundleIds = getAvailableBundleIds;
exports.parseContainerPath = parseContainerPath;
exports.default = exports.commands = void 0;

require("source-map-support/register");

var _lodash = _interopRequireDefault(require("lodash"));

var _appiumSupport = require("appium-support");

var _path = _interopRequireDefault(require("path"));

var _logger = _interopRequireDefault(require("../logger"));

var _teen_process = require("teen_process");

var _bluebird = _interopRequireDefault(require("bluebird"));

var _appiumIosDevice = require("appium-ios-device");

const CONTAINER_PATH_MARKER = '@';
const CONTAINER_PATH_PATTERN = new RegExp(`^${CONTAINER_PATH_MARKER}([^/]+)/(.*)`);
const CONTAINER_TYPE_SEPARATOR = ':';
const IFUSE_CONTAINER_DOCUMENTS = 'documents';
const CONTAINER_DOCUMENTS_PATH = 'Documents';
const IO_TIMEOUT = 60000;
const OBJECT_NOT_FOUND_ERROR_MESSAGE = 'OBJECT_NOT_FOUND';
const MAX_PULL_CHUNK_SIZE = 5;
const commands = {};
exports.commands = commands;

function verifyIsSubPath(originalPath, root) {
  const normalizedRoot = _path.default.normalize(root);

  const normalizedPath = _path.default.normalize(_path.default.dirname(originalPath));

  if (normalizedRoot !== originalPath && !normalizedPath.startsWith(normalizedRoot)) {
    _logger.default.errorAndThrow(`'${normalizedPath}' is expected to be a subpath of '${normalizedRoot}'`);
  }
}

async function createAfcClient(udid, bundleId, containerType) {
  if (!bundleId) {
    return await _appiumIosDevice.services.startAfcService(udid);
  }

  const service = await _appiumIosDevice.services.startHouseArrestService(udid);

  if (isDocuments(containerType)) {
    return await service.vendDocuments(bundleId);
  } else {
    return await service.vendContainer(bundleId);
  }
}

function isDocuments(containerType) {
  return _lodash.default.toLower(containerType) === IFUSE_CONTAINER_DOCUMENTS;
}

async function mkdirpDevice(service, dir) {
  if (dir === '.' || dir === '/') {
    return;
  }

  try {
    await service.listDirectory(dir);
    return;
  } catch (e) {
    await mkdirpDevice(service, _path.default.dirname(dir));
  }

  await service.createDirectory(dir);
}

async function createService(udid, remotePath) {
  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer,
      containerType
    } = await parseContainerPath(remotePath);
    const service = await createAfcClient(udid, bundleId, containerType);
    const relativePath = isDocuments(containerType) ? _path.default.join(CONTAINER_DOCUMENTS_PATH, pathInContainer) : pathInContainer;
    return {
      service,
      relativePath
    };
  } else {
    const service = await createAfcClient(udid);
    const relativePath = remotePath;
    return {
      service,
      relativePath
    };
  }
}

async function pullFileFromRealDevice(service, relativePath) {
  const stream = await service.createReadStream(relativePath, {
    autoDestroy: true
  });
  const pullPromise = new _bluebird.default((resolve, reject) => {
    stream.on('close', resolve);
    stream.on('error', reject);
  });
  const buffers = [];
  stream.on('data', data => buffers.push(data));

  try {
    await pullPromise.timeout(IO_TIMEOUT);
  } catch (e) {
    throw new Error(`Couldn't pull the file '${relativePath}' ` + `within the given timeout ${IO_TIMEOUT}ms. Original error: ${e.message}`);
  }

  return Buffer.concat(buffers).toString('base64');
}

async function pullFolderFromRealDevice(service, relativePath) {
  const tmpFolder = await _appiumSupport.tempDir.openDir();

  try {
    const folderPath = _path.default.join(tmpFolder, relativePath);

    await (0, _appiumSupport.mkdirp)(folderPath);
    const pullPromises = [];

    const waitForPullChunks = async () => {
      if (_lodash.default.isEmpty(pullPromises)) {
        return;
      }

      try {
        await _bluebird.default.all(pullPromises).timeout(IO_TIMEOUT);
      } catch (e) {
        throw new Error(`Couldn't pull all items in the folder '${relativePath}' ` + `within the given timeout ${IO_TIMEOUT}ms. Original error: ${e.message}`);
      }
    };

    await service.walkDir(relativePath, true, async (itemPath, isDir) => {
      const pathOnServer = _path.default.join(tmpFolder, itemPath);

      if (isDir) {
        await _appiumSupport.fs.mkdir(pathOnServer);
        return;
      }

      const readStream = await service.createReadStream(itemPath, {
        autoDestroy: true
      });

      const writeStream = _appiumSupport.fs.createWriteStream(pathOnServer, {
        autoClose: true
      });

      pullPromises.push(new _bluebird.default((resolve, reject) => {
        writeStream.on('close', resolve);

        const onStreamingError = e => {
          readStream.unpipe(writeStream);
          reject(e);
        };

        writeStream.on('error', onStreamingError);
        readStream.on('error', onStreamingError);
      }));
      readStream.pipe(writeStream);

      if (pullPromises.length % MAX_PULL_CHUNK_SIZE === 0) {
        await waitForPullChunks();
      }
    });
    await waitForPullChunks();
    return (await _appiumSupport.zip.toInMemoryZip(folderPath, {
      encodeToBase64: true
    })).toString();
  } finally {
    await _appiumSupport.fs.rimraf(tmpFolder);
  }
}

async function parseContainerPath(remotePath, containerRootSupplier) {
  const match = CONTAINER_PATH_PATTERN.exec(remotePath);

  if (!match) {
    _logger.default.errorAndThrow(`It is expected that package identifier ` + `starts with '${CONTAINER_PATH_MARKER}' and is separated from the ` + `relative path with a single slash. '${remotePath}' is given instead`);
  }

  let [, bundleId, relativePath] = match;
  let containerType = null;
  const typeSeparatorPos = bundleId.indexOf(CONTAINER_TYPE_SEPARATOR);

  if (typeSeparatorPos > 0 && typeSeparatorPos < bundleId.length - 1) {
    containerType = bundleId.substring(typeSeparatorPos + 1);

    _logger.default.debug(`Parsed container type: ${containerType}`);

    bundleId = bundleId.substring(0, typeSeparatorPos);
  }

  if (_lodash.default.isNil(containerRootSupplier)) {
    const pathInContainer = relativePath;
    return {
      bundleId,
      pathInContainer,
      containerType
    };
  }

  const containerRoot = _lodash.default.isFunction(containerRootSupplier) ? await containerRootSupplier(bundleId, containerType) : containerRootSupplier;

  const pathInContainer = _path.default.posix.resolve(containerRoot, relativePath);

  verifyIsSubPath(pathInContainer, containerRoot);
  return {
    bundleId,
    pathInContainer,
    containerType
  };
}

async function pushFileToSimulator(device, remotePath, base64Data) {
  const buffer = Buffer.from(base64Data, 'base64');

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will put the data into '${dstPath}'`);

    if (!(await _appiumSupport.fs.exists(_path.default.dirname(dstPath)))) {
      _logger.default.debug(`The destination folder '${_path.default.dirname(dstPath)}' does not exist. Creating...`);

      await (0, _appiumSupport.mkdirp)(_path.default.dirname(dstPath));
    }

    await _appiumSupport.fs.writeFile(dstPath, buffer);
    return;
  }

  const dstFolder = await _appiumSupport.tempDir.openDir();

  const dstPath = _path.default.resolve(dstFolder, _path.default.basename(remotePath));

  try {
    await _appiumSupport.fs.writeFile(dstPath, buffer);
    await device.simctl.addMedia(dstPath);
  } finally {
    await _appiumSupport.fs.rimraf(dstFolder);
  }
}

async function pushFileToRealDevice(device, remotePath, base64Data) {
  const {
    service,
    relativePath
  } = await createService(device.udid, remotePath);

  try {
    await mkdirpDevice(service, _path.default.dirname(relativePath));
    const stream = await service.createWriteStream(relativePath, {
      autoDestroy: true
    });
    let pushError = null;
    const pushPromise = new _bluebird.default((resolve, reject) => {
      stream.on('error', e => {
        pushError = e;
      });
      stream.on('close', () => {
        if (pushError) {
          reject(pushError);
        } else {
          resolve();
        }
      });
    });
    stream.write(Buffer.from(base64Data, 'base64'));
    stream.end();

    try {
      await pushPromise.timeout(IO_TIMEOUT);
    } catch (e) {
      throw new Error(`Could not push the file within the given timeout ${IO_TIMEOUT}ms. ` + `Original error: ${e.message}`);
    }
  } finally {
    service.close();
  }
}

async function pullFromSimulator(device, remotePath, isFile) {
  let pathOnServer;

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `Will get the data from '${dstPath}'`);

    pathOnServer = dstPath;
  } else {
    const simRoot = device.getDir();
    pathOnServer = _path.default.posix.join(simRoot, remotePath);
    verifyIsSubPath(pathOnServer, simRoot);

    _logger.default.info(`Got the full item path: ${pathOnServer}`);
  }

  if (!(await _appiumSupport.fs.exists(pathOnServer))) {
    _logger.default.errorAndThrow(`The remote ${isFile ? 'file' : 'folder'} at '${pathOnServer}' does not exist`);
  }

  const buffer = isFile ? await _appiumSupport.util.toInMemoryBase64(pathOnServer) : await _appiumSupport.zip.toInMemoryZip(pathOnServer, {
    encodeToBase64: true
  });
  return buffer.toString();
}

async function pullFromRealDevice(device, remotePath, isFile) {
  const {
    service,
    relativePath
  } = await createService(device.udid, remotePath);

  try {
    const fileInfo = await service.getFileInfo(relativePath);

    if (isFile && fileInfo.isDirectory()) {
      throw new Error(`The requested path is not a file. Path: '${remotePath}'`);
    }

    if (!isFile && !fileInfo.isDirectory()) {
      throw new Error(`The requested path is not a folder. Path: '${remotePath}'`);
    }

    if (fileInfo.isFile()) {
      return await pullFileFromRealDevice(service, relativePath);
    } else {
      return await pullFolderFromRealDevice(service, relativePath);
    }
  } catch (e) {
    if (e.message.includes(OBJECT_NOT_FOUND_ERROR_MESSAGE)) {
      throw new Error(`Path '${remotePath}' does not exist on the device`);
    }

    throw e;
  } finally {
    service.close();
  }
}

async function deleteFromSimulator(device, remotePath) {
  let pathOnServer;

  if (CONTAINER_PATH_PATTERN.test(remotePath)) {
    const {
      bundleId,
      pathInContainer: dstPath
    } = await parseContainerPath(remotePath, async (appBundle, containerType) => await device.simctl.getAppContainer(appBundle, containerType));

    _logger.default.info(`Parsed bundle identifier '${bundleId}' from '${remotePath}'. ` + `'${dstPath}' will be deleted`);

    pathOnServer = dstPath;
  } else {
    const simRoot = device.getDir();
    pathOnServer = _path.default.posix.join(simRoot, remotePath);
    verifyIsSubPath(pathOnServer, simRoot);

    _logger.default.info(`Got the full path: ${pathOnServer}`);
  }

  if (!(await _appiumSupport.fs.exists(pathOnServer))) {
    _logger.default.errorAndThrow(`The remote path at '${pathOnServer}' does not exist`);
  }

  await _appiumSupport.fs.rimraf(pathOnServer);
}

async function deleteFromRealDevice(device, remotePath) {
  const {
    service,
    relativePath
  } = await createService(device.udid, remotePath);

  try {
    await service.deleteDirectory(relativePath);
  } catch (e) {
    if (e.message.includes(OBJECT_NOT_FOUND_ERROR_MESSAGE)) {
      throw new Error(`Path '${remotePath}' does not exist on the device`);
    }

    throw e;
  } finally {
    service.close();
  }
}

async function getAvailableBundleIds(udid) {
  const service = await _appiumIosDevice.services.startInstallationProxyService(udid);

  try {
    const applications = await service.listApplications({
      applicationType: 'User'
    });
    const bundleIds = [];

    for (const [key, value] of Object.entries(applications)) {
      if (!value.UIFileSharingEnabled) {
        continue;
      }

      bundleIds.push(key);
    }

    return bundleIds;
  } finally {
    service.close();
  }
}

commands.pushFile = async function pushFile(remotePath, base64Data) {
  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  if (_lodash.default.isArray(base64Data)) {
    base64Data = Buffer.from(base64Data).toString('utf8');
  }

  return this.isSimulator() ? await pushFileToSimulator(this.opts.device, remotePath, base64Data) : await pushFileToRealDevice(this.opts.device, remotePath, base64Data);
};

commands.pullFile = async function pullFile(remotePath) {
  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  return this.isSimulator() ? await pullFromSimulator(this.opts.device, remotePath, true) : await pullFromRealDevice(this.opts.device, remotePath, true);
};

async function deleteFileOrFolder(device, remotePath, isSimulator) {
  return isSimulator ? await deleteFromSimulator(device, remotePath) : await deleteFromRealDevice(device, remotePath);
}

commands.mobileDeleteFolder = async function mobileDeleteFolder(opts = {}) {
  let {
    remotePath
  } = opts;

  if (!remotePath.endsWith('/')) {
    remotePath = `${remotePath}/`;
  }

  return await deleteFileOrFolder(this.opts.device, remotePath, this.isSimulator());
};

commands.mobileDeleteFile = async function mobileDeleteFile(opts = {}) {
  const {
    remotePath
  } = opts;

  if (remotePath.endsWith('/')) {
    _logger.default.errorAndThrow(`It is expected that remote path points to a file and not to a folder. ` + `'${remotePath}' is given instead`);
  }

  return await deleteFileOrFolder(this.opts.device, remotePath, this.isSimulator());
};

commands.getSimFileFullPath = async function getSimFileFullPath(remotePath) {
  let basePath = this.opts.device.getDir();
  let appName = null;

  if (this.opts.app) {
    let appNameRegex = new RegExp(`\\${_path.default.sep}([\\w-]+\\.app)`);
    let appNameMatches = appNameRegex.exec(this.opts.app);

    if (appNameMatches) {
      appName = appNameMatches[1];
    }
  }

  if (_appiumSupport.system.isWindows()) {
    if (remotePath.indexof('://') === 1) {
      remotePath = remotePath.slice(4);
    }
  } else {
    if (remotePath.indexOf('/') === 0) {
      remotePath = remotePath.slice(1);
    }
  }

  if (remotePath.startsWith(appName)) {
    let findPath = basePath;

    if (!this.opts.platformVersion || _appiumSupport.util.compareVersions(this.opts.platformVersion, '>=', '8.0')) {
      findPath = _path.default.resolve(basePath, 'Containers', 'Bundle');
    }

    findPath = findPath.replace(/\s/g, '\\ ');
    let {
      stdout
    } = await (0, _teen_process.exec)('find', [findPath, '-name', appName]);
    let appRoot = stdout.replace(/\n$/, '');
    let subPath = remotePath.substring(appName.length + 1);

    let fullPath = _path.default.resolve(appRoot, subPath);

    _logger.default.debug(`Finding app-relative file: '${fullPath}'`);

    return fullPath;
  }

  let fullPath = _path.default.resolve(basePath, remotePath);

  _logger.default.debug(`Finding sim-relative file: ${fullPath}`);

  return fullPath;
};

commands.pullFolder = async function pullFolder(remotePath) {
  if (!remotePath.endsWith('/')) {
    remotePath = `${remotePath}/`;
  }

  return this.isSimulator() ? await pullFromSimulator(this.opts.device, remotePath, false) : await pullFromRealDevice(this.opts.device, remotePath, false);
};

var _default = commands;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9jb21tYW5kcy9maWxlLW1vdmVtZW50LmpzIl0sIm5hbWVzIjpbIkNPTlRBSU5FUl9QQVRIX01BUktFUiIsIkNPTlRBSU5FUl9QQVRIX1BBVFRFUk4iLCJSZWdFeHAiLCJDT05UQUlORVJfVFlQRV9TRVBBUkFUT1IiLCJJRlVTRV9DT05UQUlORVJfRE9DVU1FTlRTIiwiQ09OVEFJTkVSX0RPQ1VNRU5UU19QQVRIIiwiSU9fVElNRU9VVCIsIk9CSkVDVF9OT1RfRk9VTkRfRVJST1JfTUVTU0FHRSIsIk1BWF9QVUxMX0NIVU5LX1NJWkUiLCJjb21tYW5kcyIsInZlcmlmeUlzU3ViUGF0aCIsIm9yaWdpbmFsUGF0aCIsInJvb3QiLCJub3JtYWxpemVkUm9vdCIsInBhdGgiLCJub3JtYWxpemUiLCJub3JtYWxpemVkUGF0aCIsImRpcm5hbWUiLCJzdGFydHNXaXRoIiwibG9nIiwiZXJyb3JBbmRUaHJvdyIsImNyZWF0ZUFmY0NsaWVudCIsInVkaWQiLCJidW5kbGVJZCIsImNvbnRhaW5lclR5cGUiLCJzZXJ2aWNlcyIsInN0YXJ0QWZjU2VydmljZSIsInNlcnZpY2UiLCJzdGFydEhvdXNlQXJyZXN0U2VydmljZSIsImlzRG9jdW1lbnRzIiwidmVuZERvY3VtZW50cyIsInZlbmRDb250YWluZXIiLCJfIiwidG9Mb3dlciIsIm1rZGlycERldmljZSIsImRpciIsImxpc3REaXJlY3RvcnkiLCJlIiwiY3JlYXRlRGlyZWN0b3J5IiwiY3JlYXRlU2VydmljZSIsInJlbW90ZVBhdGgiLCJ0ZXN0IiwicGF0aEluQ29udGFpbmVyIiwicGFyc2VDb250YWluZXJQYXRoIiwicmVsYXRpdmVQYXRoIiwiam9pbiIsInB1bGxGaWxlRnJvbVJlYWxEZXZpY2UiLCJzdHJlYW0iLCJjcmVhdGVSZWFkU3RyZWFtIiwiYXV0b0Rlc3Ryb3kiLCJwdWxsUHJvbWlzZSIsIkIiLCJyZXNvbHZlIiwicmVqZWN0Iiwib24iLCJidWZmZXJzIiwiZGF0YSIsInB1c2giLCJ0aW1lb3V0IiwiRXJyb3IiLCJtZXNzYWdlIiwiQnVmZmVyIiwiY29uY2F0IiwidG9TdHJpbmciLCJwdWxsRm9sZGVyRnJvbVJlYWxEZXZpY2UiLCJ0bXBGb2xkZXIiLCJ0ZW1wRGlyIiwib3BlbkRpciIsImZvbGRlclBhdGgiLCJwdWxsUHJvbWlzZXMiLCJ3YWl0Rm9yUHVsbENodW5rcyIsImlzRW1wdHkiLCJhbGwiLCJ3YWxrRGlyIiwiaXRlbVBhdGgiLCJpc0RpciIsInBhdGhPblNlcnZlciIsImZzIiwibWtkaXIiLCJyZWFkU3RyZWFtIiwid3JpdGVTdHJlYW0iLCJjcmVhdGVXcml0ZVN0cmVhbSIsImF1dG9DbG9zZSIsIm9uU3RyZWFtaW5nRXJyb3IiLCJ1bnBpcGUiLCJwaXBlIiwibGVuZ3RoIiwiemlwIiwidG9Jbk1lbW9yeVppcCIsImVuY29kZVRvQmFzZTY0IiwicmltcmFmIiwiY29udGFpbmVyUm9vdFN1cHBsaWVyIiwibWF0Y2giLCJleGVjIiwidHlwZVNlcGFyYXRvclBvcyIsImluZGV4T2YiLCJzdWJzdHJpbmciLCJkZWJ1ZyIsImlzTmlsIiwiY29udGFpbmVyUm9vdCIsImlzRnVuY3Rpb24iLCJwb3NpeCIsInB1c2hGaWxlVG9TaW11bGF0b3IiLCJkZXZpY2UiLCJiYXNlNjREYXRhIiwiYnVmZmVyIiwiZnJvbSIsImRzdFBhdGgiLCJhcHBCdW5kbGUiLCJzaW1jdGwiLCJnZXRBcHBDb250YWluZXIiLCJpbmZvIiwiZXhpc3RzIiwid3JpdGVGaWxlIiwiZHN0Rm9sZGVyIiwiYmFzZW5hbWUiLCJhZGRNZWRpYSIsInB1c2hGaWxlVG9SZWFsRGV2aWNlIiwicHVzaEVycm9yIiwicHVzaFByb21pc2UiLCJ3cml0ZSIsImVuZCIsImNsb3NlIiwicHVsbEZyb21TaW11bGF0b3IiLCJpc0ZpbGUiLCJzaW1Sb290IiwiZ2V0RGlyIiwidXRpbCIsInRvSW5NZW1vcnlCYXNlNjQiLCJwdWxsRnJvbVJlYWxEZXZpY2UiLCJmaWxlSW5mbyIsImdldEZpbGVJbmZvIiwiaXNEaXJlY3RvcnkiLCJpbmNsdWRlcyIsImRlbGV0ZUZyb21TaW11bGF0b3IiLCJkZWxldGVGcm9tUmVhbERldmljZSIsImRlbGV0ZURpcmVjdG9yeSIsImdldEF2YWlsYWJsZUJ1bmRsZUlkcyIsInN0YXJ0SW5zdGFsbGF0aW9uUHJveHlTZXJ2aWNlIiwiYXBwbGljYXRpb25zIiwibGlzdEFwcGxpY2F0aW9ucyIsImFwcGxpY2F0aW9uVHlwZSIsImJ1bmRsZUlkcyIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsIlVJRmlsZVNoYXJpbmdFbmFibGVkIiwicHVzaEZpbGUiLCJlbmRzV2l0aCIsImlzQXJyYXkiLCJpc1NpbXVsYXRvciIsIm9wdHMiLCJwdWxsRmlsZSIsImRlbGV0ZUZpbGVPckZvbGRlciIsIm1vYmlsZURlbGV0ZUZvbGRlciIsIm1vYmlsZURlbGV0ZUZpbGUiLCJnZXRTaW1GaWxlRnVsbFBhdGgiLCJiYXNlUGF0aCIsImFwcE5hbWUiLCJhcHAiLCJhcHBOYW1lUmVnZXgiLCJzZXAiLCJhcHBOYW1lTWF0Y2hlcyIsInN5c3RlbSIsImlzV2luZG93cyIsImluZGV4b2YiLCJzbGljZSIsImZpbmRQYXRoIiwicGxhdGZvcm1WZXJzaW9uIiwiY29tcGFyZVZlcnNpb25zIiwicmVwbGFjZSIsInN0ZG91dCIsImFwcFJvb3QiLCJzdWJQYXRoIiwiZnVsbFBhdGgiLCJwdWxsRm9sZGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBQ0E7O0FBRUEsTUFBTUEscUJBQXFCLEdBQUcsR0FBOUI7QUFFQSxNQUFNQyxzQkFBc0IsR0FBRyxJQUFJQyxNQUFKLENBQVksSUFBR0YscUJBQXNCLGNBQXJDLENBQS9CO0FBQ0EsTUFBTUcsd0JBQXdCLEdBQUcsR0FBakM7QUFDQSxNQUFNQyx5QkFBeUIsR0FBRyxXQUFsQztBQUNBLE1BQU1DLHdCQUF3QixHQUFHLFdBQWpDO0FBQ0EsTUFBTUMsVUFBVSxHQUFHLEtBQW5CO0FBQ0EsTUFBTUMsOEJBQThCLEdBQUcsa0JBQXZDO0FBQ0EsTUFBTUMsbUJBQW1CLEdBQUcsQ0FBNUI7QUFFQSxNQUFNQyxRQUFRLEdBQUcsRUFBakI7OztBQUVBLFNBQVNDLGVBQVQsQ0FBMEJDLFlBQTFCLEVBQXdDQyxJQUF4QyxFQUE4QztBQUM1QyxRQUFNQyxjQUFjLEdBQUdDLGNBQUtDLFNBQUwsQ0FBZUgsSUFBZixDQUF2Qjs7QUFDQSxRQUFNSSxjQUFjLEdBQUdGLGNBQUtDLFNBQUwsQ0FBZUQsY0FBS0csT0FBTCxDQUFhTixZQUFiLENBQWYsQ0FBdkI7O0FBRUEsTUFBSUUsY0FBYyxLQUFLRixZQUFuQixJQUFtQyxDQUFDSyxjQUFjLENBQUNFLFVBQWYsQ0FBMEJMLGNBQTFCLENBQXhDLEVBQW1GO0FBQ2pGTSxvQkFBSUMsYUFBSixDQUFtQixJQUFHSixjQUFlLHFDQUFvQ0gsY0FBZSxHQUF4RjtBQUNEO0FBQ0Y7O0FBRUQsZUFBZVEsZUFBZixDQUFnQ0MsSUFBaEMsRUFBc0NDLFFBQXRDLEVBQWdEQyxhQUFoRCxFQUErRDtBQUM3RCxNQUFJLENBQUNELFFBQUwsRUFBZTtBQUNiLFdBQU8sTUFBTUUsMEJBQVNDLGVBQVQsQ0FBeUJKLElBQXpCLENBQWI7QUFDRDs7QUFDRCxRQUFNSyxPQUFPLEdBQUcsTUFBTUYsMEJBQVNHLHVCQUFULENBQWlDTixJQUFqQyxDQUF0Qjs7QUFDQSxNQUFJTyxXQUFXLENBQUNMLGFBQUQsQ0FBZixFQUFnQztBQUM5QixXQUFPLE1BQU1HLE9BQU8sQ0FBQ0csYUFBUixDQUFzQlAsUUFBdEIsQ0FBYjtBQUNELEdBRkQsTUFFTztBQUNMLFdBQU8sTUFBTUksT0FBTyxDQUFDSSxhQUFSLENBQXNCUixRQUF0QixDQUFiO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTTSxXQUFULENBQXNCTCxhQUF0QixFQUFxQztBQUNuQyxTQUFPUSxnQkFBRUMsT0FBRixDQUFVVCxhQUFWLE1BQTZCcEIseUJBQXBDO0FBQ0Q7O0FBRUQsZUFBZThCLFlBQWYsQ0FBNkJQLE9BQTdCLEVBQXNDUSxHQUF0QyxFQUEyQztBQUN6QyxNQUFJQSxHQUFHLEtBQUssR0FBUixJQUFlQSxHQUFHLEtBQUssR0FBM0IsRUFBZ0M7QUFDOUI7QUFDRDs7QUFDRCxNQUFJO0FBQ0YsVUFBTVIsT0FBTyxDQUFDUyxhQUFSLENBQXNCRCxHQUF0QixDQUFOO0FBQ0E7QUFDRCxHQUhELENBR0UsT0FBT0UsQ0FBUCxFQUFVO0FBRVYsVUFBTUgsWUFBWSxDQUFDUCxPQUFELEVBQVViLGNBQUtHLE9BQUwsQ0FBYWtCLEdBQWIsQ0FBVixDQUFsQjtBQUNEOztBQUNELFFBQU1SLE9BQU8sQ0FBQ1csZUFBUixDQUF3QkgsR0FBeEIsQ0FBTjtBQUNEOztBQUVELGVBQWVJLGFBQWYsQ0FBOEJqQixJQUE5QixFQUFvQ2tCLFVBQXBDLEVBQWdEO0FBQzlDLE1BQUl2QyxzQkFBc0IsQ0FBQ3dDLElBQXZCLENBQTRCRCxVQUE1QixDQUFKLEVBQTZDO0FBQzNDLFVBQU07QUFBQ2pCLE1BQUFBLFFBQUQ7QUFBV21CLE1BQUFBLGVBQVg7QUFBNEJsQixNQUFBQTtBQUE1QixRQUE2QyxNQUFNbUIsa0JBQWtCLENBQUNILFVBQUQsQ0FBM0U7QUFDQSxVQUFNYixPQUFPLEdBQUcsTUFBTU4sZUFBZSxDQUFDQyxJQUFELEVBQU9DLFFBQVAsRUFBaUJDLGFBQWpCLENBQXJDO0FBQ0EsVUFBTW9CLFlBQVksR0FBR2YsV0FBVyxDQUFDTCxhQUFELENBQVgsR0FBNkJWLGNBQUsrQixJQUFMLENBQVV4Qyx3QkFBVixFQUFvQ3FDLGVBQXBDLENBQTdCLEdBQW9GQSxlQUF6RztBQUNBLFdBQU87QUFBQ2YsTUFBQUEsT0FBRDtBQUFVaUIsTUFBQUE7QUFBVixLQUFQO0FBQ0QsR0FMRCxNQUtPO0FBQ0wsVUFBTWpCLE9BQU8sR0FBRyxNQUFNTixlQUFlLENBQUNDLElBQUQsQ0FBckM7QUFDQSxVQUFNc0IsWUFBWSxHQUFHSixVQUFyQjtBQUNBLFdBQU87QUFBQ2IsTUFBQUEsT0FBRDtBQUFVaUIsTUFBQUE7QUFBVixLQUFQO0FBQ0Q7QUFDRjs7QUFFRCxlQUFlRSxzQkFBZixDQUF1Q25CLE9BQXZDLEVBQWdEaUIsWUFBaEQsRUFBOEQ7QUFDNUQsUUFBTUcsTUFBTSxHQUFHLE1BQU1wQixPQUFPLENBQUNxQixnQkFBUixDQUF5QkosWUFBekIsRUFBdUM7QUFBRUssSUFBQUEsV0FBVyxFQUFFO0FBQWYsR0FBdkMsQ0FBckI7QUFDQSxRQUFNQyxXQUFXLEdBQUcsSUFBSUMsaUJBQUosQ0FBTSxDQUFDQyxPQUFELEVBQVVDLE1BQVYsS0FBcUI7QUFDN0NOLElBQUFBLE1BQU0sQ0FBQ08sRUFBUCxDQUFVLE9BQVYsRUFBbUJGLE9BQW5CO0FBQ0FMLElBQUFBLE1BQU0sQ0FBQ08sRUFBUCxDQUFVLE9BQVYsRUFBbUJELE1BQW5CO0FBQ0QsR0FIbUIsQ0FBcEI7QUFJQSxRQUFNRSxPQUFPLEdBQUcsRUFBaEI7QUFDQVIsRUFBQUEsTUFBTSxDQUFDTyxFQUFQLENBQVUsTUFBVixFQUFtQkUsSUFBRCxJQUFVRCxPQUFPLENBQUNFLElBQVIsQ0FBYUQsSUFBYixDQUE1Qjs7QUFDQSxNQUFJO0FBQ0YsVUFBTU4sV0FBVyxDQUFDUSxPQUFaLENBQW9CcEQsVUFBcEIsQ0FBTjtBQUNELEdBRkQsQ0FFRSxPQUFPK0IsQ0FBUCxFQUFVO0FBQ1YsVUFBTSxJQUFJc0IsS0FBSixDQUFXLDJCQUEwQmYsWUFBYSxJQUF4QyxHQUNiLDRCQUEyQnRDLFVBQVcsdUJBQXNCK0IsQ0FBQyxDQUFDdUIsT0FBUSxFQURuRSxDQUFOO0FBRUQ7O0FBQ0QsU0FBT0MsTUFBTSxDQUFDQyxNQUFQLENBQWNQLE9BQWQsRUFBdUJRLFFBQXZCLENBQWdDLFFBQWhDLENBQVA7QUFDRDs7QUFFRCxlQUFlQyx3QkFBZixDQUF5Q3JDLE9BQXpDLEVBQWtEaUIsWUFBbEQsRUFBZ0U7QUFDOUQsUUFBTXFCLFNBQVMsR0FBRyxNQUFNQyx1QkFBUUMsT0FBUixFQUF4Qjs7QUFDQSxNQUFJO0FBQ0YsVUFBTUMsVUFBVSxHQUFHdEQsY0FBSytCLElBQUwsQ0FBVW9CLFNBQVYsRUFBcUJyQixZQUFyQixDQUFuQjs7QUFDQSxVQUFNLDJCQUFPd0IsVUFBUCxDQUFOO0FBQ0EsVUFBTUMsWUFBWSxHQUFHLEVBQXJCOztBQUNBLFVBQU1DLGlCQUFpQixHQUFHLFlBQVk7QUFDcEMsVUFBSXRDLGdCQUFFdUMsT0FBRixDQUFVRixZQUFWLENBQUosRUFBNkI7QUFDM0I7QUFDRDs7QUFFRCxVQUFJO0FBQ0YsY0FBTWxCLGtCQUFFcUIsR0FBRixDQUFNSCxZQUFOLEVBQW9CWCxPQUFwQixDQUE0QnBELFVBQTVCLENBQU47QUFDRCxPQUZELENBRUUsT0FBTytCLENBQVAsRUFBVTtBQUNWLGNBQU0sSUFBSXNCLEtBQUosQ0FBVywwQ0FBeUNmLFlBQWEsSUFBdkQsR0FDYiw0QkFBMkJ0QyxVQUFXLHVCQUFzQitCLENBQUMsQ0FBQ3VCLE9BQVEsRUFEbkUsQ0FBTjtBQUVEO0FBQ0YsS0FYRDs7QUFZQSxVQUFNakMsT0FBTyxDQUFDOEMsT0FBUixDQUFnQjdCLFlBQWhCLEVBQThCLElBQTlCLEVBQW9DLE9BQU84QixRQUFQLEVBQWlCQyxLQUFqQixLQUEyQjtBQUNuRSxZQUFNQyxZQUFZLEdBQUc5RCxjQUFLK0IsSUFBTCxDQUFVb0IsU0FBVixFQUFxQlMsUUFBckIsQ0FBckI7O0FBQ0EsVUFBSUMsS0FBSixFQUFXO0FBQ1QsY0FBTUUsa0JBQUdDLEtBQUgsQ0FBU0YsWUFBVCxDQUFOO0FBQ0E7QUFDRDs7QUFFRCxZQUFNRyxVQUFVLEdBQUcsTUFBTXBELE9BQU8sQ0FBQ3FCLGdCQUFSLENBQXlCMEIsUUFBekIsRUFBbUM7QUFBQ3pCLFFBQUFBLFdBQVcsRUFBRTtBQUFkLE9BQW5DLENBQXpCOztBQUNBLFlBQU0rQixXQUFXLEdBQUdILGtCQUFHSSxpQkFBSCxDQUFxQkwsWUFBckIsRUFBbUM7QUFBQ00sUUFBQUEsU0FBUyxFQUFFO0FBQVosT0FBbkMsQ0FBcEI7O0FBQ0FiLE1BQUFBLFlBQVksQ0FBQ1osSUFBYixDQUFrQixJQUFJTixpQkFBSixDQUFNLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUMzQzJCLFFBQUFBLFdBQVcsQ0FBQzFCLEVBQVosQ0FBZSxPQUFmLEVBQXdCRixPQUF4Qjs7QUFDQSxjQUFNK0IsZ0JBQWdCLEdBQUk5QyxDQUFELElBQU87QUFDOUIwQyxVQUFBQSxVQUFVLENBQUNLLE1BQVgsQ0FBa0JKLFdBQWxCO0FBQ0EzQixVQUFBQSxNQUFNLENBQUNoQixDQUFELENBQU47QUFDRCxTQUhEOztBQUlBMkMsUUFBQUEsV0FBVyxDQUFDMUIsRUFBWixDQUFlLE9BQWYsRUFBd0I2QixnQkFBeEI7QUFDQUosUUFBQUEsVUFBVSxDQUFDekIsRUFBWCxDQUFjLE9BQWQsRUFBdUI2QixnQkFBdkI7QUFDRCxPQVJpQixDQUFsQjtBQVNBSixNQUFBQSxVQUFVLENBQUNNLElBQVgsQ0FBZ0JMLFdBQWhCOztBQUNBLFVBQUlYLFlBQVksQ0FBQ2lCLE1BQWIsR0FBc0I5RSxtQkFBdEIsS0FBOEMsQ0FBbEQsRUFBcUQ7QUFDbkQsY0FBTThELGlCQUFpQixFQUF2QjtBQUNEO0FBQ0YsS0F0QkssQ0FBTjtBQXdCQSxVQUFNQSxpQkFBaUIsRUFBdkI7QUFDQSxXQUFPLENBQUMsTUFBTWlCLG1CQUFJQyxhQUFKLENBQWtCcEIsVUFBbEIsRUFBOEI7QUFDMUNxQixNQUFBQSxjQUFjLEVBQUU7QUFEMEIsS0FBOUIsQ0FBUCxFQUVIMUIsUUFGRyxFQUFQO0FBR0QsR0E1Q0QsU0E0Q1U7QUFDUixVQUFNYyxrQkFBR2EsTUFBSCxDQUFVekIsU0FBVixDQUFOO0FBQ0Q7QUFDRjs7QUFzQkQsZUFBZXRCLGtCQUFmLENBQW1DSCxVQUFuQyxFQUErQ21ELHFCQUEvQyxFQUFzRTtBQUNwRSxRQUFNQyxLQUFLLEdBQUczRixzQkFBc0IsQ0FBQzRGLElBQXZCLENBQTRCckQsVUFBNUIsQ0FBZDs7QUFDQSxNQUFJLENBQUNvRCxLQUFMLEVBQVk7QUFDVnpFLG9CQUFJQyxhQUFKLENBQW1CLHlDQUFELEdBQ2YsZ0JBQWVwQixxQkFBc0IsOEJBRHRCLEdBRWYsdUNBQXNDd0MsVUFBVyxvQkFGcEQ7QUFHRDs7QUFDRCxNQUFJLEdBQUdqQixRQUFILEVBQWFxQixZQUFiLElBQTZCZ0QsS0FBakM7QUFDQSxNQUFJcEUsYUFBYSxHQUFHLElBQXBCO0FBQ0EsUUFBTXNFLGdCQUFnQixHQUFHdkUsUUFBUSxDQUFDd0UsT0FBVCxDQUFpQjVGLHdCQUFqQixDQUF6Qjs7QUFHQSxNQUFJMkYsZ0JBQWdCLEdBQUcsQ0FBbkIsSUFBd0JBLGdCQUFnQixHQUFHdkUsUUFBUSxDQUFDK0QsTUFBVCxHQUFrQixDQUFqRSxFQUFvRTtBQUNsRTlELElBQUFBLGFBQWEsR0FBR0QsUUFBUSxDQUFDeUUsU0FBVCxDQUFtQkYsZ0JBQWdCLEdBQUcsQ0FBdEMsQ0FBaEI7O0FBQ0EzRSxvQkFBSThFLEtBQUosQ0FBVywwQkFBeUJ6RSxhQUFjLEVBQWxEOztBQUNBRCxJQUFBQSxRQUFRLEdBQUdBLFFBQVEsQ0FBQ3lFLFNBQVQsQ0FBbUIsQ0FBbkIsRUFBc0JGLGdCQUF0QixDQUFYO0FBQ0Q7O0FBQ0QsTUFBSTlELGdCQUFFa0UsS0FBRixDQUFRUCxxQkFBUixDQUFKLEVBQW9DO0FBQ2xDLFVBQU1qRCxlQUFlLEdBQUdFLFlBQXhCO0FBQ0EsV0FBTztBQUFFckIsTUFBQUEsUUFBRjtBQUFZbUIsTUFBQUEsZUFBWjtBQUE2QmxCLE1BQUFBO0FBQTdCLEtBQVA7QUFDRDs7QUFDRCxRQUFNMkUsYUFBYSxHQUFHbkUsZ0JBQUVvRSxVQUFGLENBQWFULHFCQUFiLElBQ2xCLE1BQU1BLHFCQUFxQixDQUFDcEUsUUFBRCxFQUFXQyxhQUFYLENBRFQsR0FFbEJtRSxxQkFGSjs7QUFHQSxRQUFNakQsZUFBZSxHQUFHNUIsY0FBS3VGLEtBQUwsQ0FBV2pELE9BQVgsQ0FBbUIrQyxhQUFuQixFQUFrQ3ZELFlBQWxDLENBQXhCOztBQUNBbEMsRUFBQUEsZUFBZSxDQUFDZ0MsZUFBRCxFQUFrQnlELGFBQWxCLENBQWY7QUFDQSxTQUFPO0FBQUM1RSxJQUFBQSxRQUFEO0FBQVdtQixJQUFBQSxlQUFYO0FBQTRCbEIsSUFBQUE7QUFBNUIsR0FBUDtBQUNEOztBQW9CRCxlQUFlOEUsbUJBQWYsQ0FBb0NDLE1BQXBDLEVBQTRDL0QsVUFBNUMsRUFBd0RnRSxVQUF4RCxFQUFvRTtBQUNsRSxRQUFNQyxNQUFNLEdBQUc1QyxNQUFNLENBQUM2QyxJQUFQLENBQVlGLFVBQVosRUFBd0IsUUFBeEIsQ0FBZjs7QUFDQSxNQUFJdkcsc0JBQXNCLENBQUN3QyxJQUF2QixDQUE0QkQsVUFBNUIsQ0FBSixFQUE2QztBQUMzQyxVQUFNO0FBQUNqQixNQUFBQSxRQUFEO0FBQVdtQixNQUFBQSxlQUFlLEVBQUVpRTtBQUE1QixRQUF1QyxNQUFNaEUsa0JBQWtCLENBQUNILFVBQUQsRUFDbkUsT0FBT29FLFNBQVAsRUFBa0JwRixhQUFsQixLQUFvQyxNQUFNK0UsTUFBTSxDQUFDTSxNQUFQLENBQWNDLGVBQWQsQ0FBOEJGLFNBQTlCLEVBQXlDcEYsYUFBekMsQ0FEeUIsQ0FBckU7O0FBRUFMLG9CQUFJNEYsSUFBSixDQUFVLDZCQUE0QnhGLFFBQVMsV0FBVWlCLFVBQVcsS0FBM0QsR0FDTiwyQkFBMEJtRSxPQUFRLEdBRHJDOztBQUVBLFFBQUksRUFBQyxNQUFNOUIsa0JBQUdtQyxNQUFILENBQVVsRyxjQUFLRyxPQUFMLENBQWEwRixPQUFiLENBQVYsQ0FBUCxDQUFKLEVBQTZDO0FBQzNDeEYsc0JBQUk4RSxLQUFKLENBQVcsMkJBQTBCbkYsY0FBS0csT0FBTCxDQUFhMEYsT0FBYixDQUFzQiwrQkFBM0Q7O0FBQ0EsWUFBTSwyQkFBTzdGLGNBQUtHLE9BQUwsQ0FBYTBGLE9BQWIsQ0FBUCxDQUFOO0FBQ0Q7O0FBQ0QsVUFBTTlCLGtCQUFHb0MsU0FBSCxDQUFhTixPQUFiLEVBQXNCRixNQUF0QixDQUFOO0FBQ0E7QUFDRDs7QUFDRCxRQUFNUyxTQUFTLEdBQUcsTUFBTWhELHVCQUFRQyxPQUFSLEVBQXhCOztBQUNBLFFBQU13QyxPQUFPLEdBQUc3RixjQUFLc0MsT0FBTCxDQUFhOEQsU0FBYixFQUF3QnBHLGNBQUtxRyxRQUFMLENBQWMzRSxVQUFkLENBQXhCLENBQWhCOztBQUNBLE1BQUk7QUFDRixVQUFNcUMsa0JBQUdvQyxTQUFILENBQWFOLE9BQWIsRUFBc0JGLE1BQXRCLENBQU47QUFDQSxVQUFNRixNQUFNLENBQUNNLE1BQVAsQ0FBY08sUUFBZCxDQUF1QlQsT0FBdkIsQ0FBTjtBQUNELEdBSEQsU0FHVTtBQUNSLFVBQU05QixrQkFBR2EsTUFBSCxDQUFVd0IsU0FBVixDQUFOO0FBQ0Q7QUFDRjs7QUFzQkQsZUFBZUcsb0JBQWYsQ0FBcUNkLE1BQXJDLEVBQTZDL0QsVUFBN0MsRUFBeURnRSxVQUF6RCxFQUFxRTtBQUNuRSxRQUFNO0FBQUM3RSxJQUFBQSxPQUFEO0FBQVVpQixJQUFBQTtBQUFWLE1BQTBCLE1BQU1MLGFBQWEsQ0FBQ2dFLE1BQU0sQ0FBQ2pGLElBQVIsRUFBY2tCLFVBQWQsQ0FBbkQ7O0FBQ0EsTUFBSTtBQUNGLFVBQU1OLFlBQVksQ0FBQ1AsT0FBRCxFQUFVYixjQUFLRyxPQUFMLENBQWEyQixZQUFiLENBQVYsQ0FBbEI7QUFDQSxVQUFNRyxNQUFNLEdBQUcsTUFBTXBCLE9BQU8sQ0FBQ3NELGlCQUFSLENBQTBCckMsWUFBMUIsRUFBd0M7QUFBQ0ssTUFBQUEsV0FBVyxFQUFFO0FBQWQsS0FBeEMsQ0FBckI7QUFDQSxRQUFJcUUsU0FBUyxHQUFHLElBQWhCO0FBQ0EsVUFBTUMsV0FBVyxHQUFHLElBQUlwRSxpQkFBSixDQUFNLENBQUNDLE9BQUQsRUFBVUMsTUFBVixLQUFxQjtBQUM3Q04sTUFBQUEsTUFBTSxDQUFDTyxFQUFQLENBQVUsT0FBVixFQUFvQmpCLENBQUQsSUFBTztBQUN4QmlGLFFBQUFBLFNBQVMsR0FBR2pGLENBQVo7QUFDRCxPQUZEO0FBR0FVLE1BQUFBLE1BQU0sQ0FBQ08sRUFBUCxDQUFVLE9BQVYsRUFBbUIsTUFBTTtBQUN2QixZQUFJZ0UsU0FBSixFQUFlO0FBQ2JqRSxVQUFBQSxNQUFNLENBQUNpRSxTQUFELENBQU47QUFDRCxTQUZELE1BRU87QUFDTGxFLFVBQUFBLE9BQU87QUFDUjtBQUNGLE9BTkQ7QUFPRCxLQVhtQixDQUFwQjtBQVlBTCxJQUFBQSxNQUFNLENBQUN5RSxLQUFQLENBQWEzRCxNQUFNLENBQUM2QyxJQUFQLENBQVlGLFVBQVosRUFBd0IsUUFBeEIsQ0FBYjtBQUNBekQsSUFBQUEsTUFBTSxDQUFDMEUsR0FBUDs7QUFDQSxRQUFJO0FBQ0YsWUFBTUYsV0FBVyxDQUFDN0QsT0FBWixDQUFvQnBELFVBQXBCLENBQU47QUFDRCxLQUZELENBRUUsT0FBTytCLENBQVAsRUFBVTtBQUNWLFlBQU0sSUFBSXNCLEtBQUosQ0FBVyxvREFBbURyRCxVQUFXLE1BQS9ELEdBQ2IsbUJBQWtCK0IsQ0FBQyxDQUFDdUIsT0FBUSxFQUR6QixDQUFOO0FBRUQ7QUFDRixHQXhCRCxTQXdCVTtBQUNSakMsSUFBQUEsT0FBTyxDQUFDK0YsS0FBUjtBQUNEO0FBQ0Y7O0FBa0JELGVBQWVDLGlCQUFmLENBQWtDcEIsTUFBbEMsRUFBMEMvRCxVQUExQyxFQUFzRG9GLE1BQXRELEVBQThEO0FBQzVELE1BQUloRCxZQUFKOztBQUNBLE1BQUkzRSxzQkFBc0IsQ0FBQ3dDLElBQXZCLENBQTRCRCxVQUE1QixDQUFKLEVBQTZDO0FBQzNDLFVBQU07QUFBQ2pCLE1BQUFBLFFBQUQ7QUFBV21CLE1BQUFBLGVBQWUsRUFBRWlFO0FBQTVCLFFBQXVDLE1BQU1oRSxrQkFBa0IsQ0FBQ0gsVUFBRCxFQUNuRSxPQUFPb0UsU0FBUCxFQUFrQnBGLGFBQWxCLEtBQW9DLE1BQU0rRSxNQUFNLENBQUNNLE1BQVAsQ0FBY0MsZUFBZCxDQUE4QkYsU0FBOUIsRUFBeUNwRixhQUF6QyxDQUR5QixDQUFyRTs7QUFFQUwsb0JBQUk0RixJQUFKLENBQVUsNkJBQTRCeEYsUUFBUyxXQUFVaUIsVUFBVyxLQUEzRCxHQUNOLDJCQUEwQm1FLE9BQVEsR0FEckM7O0FBRUEvQixJQUFBQSxZQUFZLEdBQUcrQixPQUFmO0FBQ0QsR0FORCxNQU1PO0FBQ0wsVUFBTWtCLE9BQU8sR0FBR3RCLE1BQU0sQ0FBQ3VCLE1BQVAsRUFBaEI7QUFDQWxELElBQUFBLFlBQVksR0FBRzlELGNBQUt1RixLQUFMLENBQVd4RCxJQUFYLENBQWdCZ0YsT0FBaEIsRUFBeUJyRixVQUF6QixDQUFmO0FBQ0E5QixJQUFBQSxlQUFlLENBQUNrRSxZQUFELEVBQWVpRCxPQUFmLENBQWY7O0FBQ0ExRyxvQkFBSTRGLElBQUosQ0FBVSwyQkFBMEJuQyxZQUFhLEVBQWpEO0FBQ0Q7O0FBQ0QsTUFBSSxFQUFDLE1BQU1DLGtCQUFHbUMsTUFBSCxDQUFVcEMsWUFBVixDQUFQLENBQUosRUFBb0M7QUFDbEN6RCxvQkFBSUMsYUFBSixDQUFtQixjQUFhd0csTUFBTSxHQUFHLE1BQUgsR0FBWSxRQUFTLFFBQU9oRCxZQUFhLGtCQUEvRTtBQUNEOztBQUNELFFBQU02QixNQUFNLEdBQUdtQixNQUFNLEdBQ2pCLE1BQU1HLG9CQUFLQyxnQkFBTCxDQUFzQnBELFlBQXRCLENBRFcsR0FFakIsTUFBTVcsbUJBQUlDLGFBQUosQ0FBa0JaLFlBQWxCLEVBQWdDO0FBQUNhLElBQUFBLGNBQWMsRUFBRTtBQUFqQixHQUFoQyxDQUZWO0FBR0EsU0FBT2dCLE1BQU0sQ0FBQzFDLFFBQVAsRUFBUDtBQUNEOztBQXlCRCxlQUFla0Usa0JBQWYsQ0FBbUMxQixNQUFuQyxFQUEyQy9ELFVBQTNDLEVBQXVEb0YsTUFBdkQsRUFBK0Q7QUFDN0QsUUFBTTtBQUFDakcsSUFBQUEsT0FBRDtBQUFVaUIsSUFBQUE7QUFBVixNQUEwQixNQUFNTCxhQUFhLENBQUNnRSxNQUFNLENBQUNqRixJQUFSLEVBQWNrQixVQUFkLENBQW5EOztBQUNBLE1BQUk7QUFDRixVQUFNMEYsUUFBUSxHQUFHLE1BQU12RyxPQUFPLENBQUN3RyxXQUFSLENBQW9CdkYsWUFBcEIsQ0FBdkI7O0FBQ0EsUUFBSWdGLE1BQU0sSUFBSU0sUUFBUSxDQUFDRSxXQUFULEVBQWQsRUFBc0M7QUFDcEMsWUFBTSxJQUFJekUsS0FBSixDQUFXLDRDQUEyQ25CLFVBQVcsR0FBakUsQ0FBTjtBQUNEOztBQUNELFFBQUksQ0FBQ29GLE1BQUQsSUFBVyxDQUFDTSxRQUFRLENBQUNFLFdBQVQsRUFBaEIsRUFBd0M7QUFDdEMsWUFBTSxJQUFJekUsS0FBSixDQUFXLDhDQUE2Q25CLFVBQVcsR0FBbkUsQ0FBTjtBQUNEOztBQUVELFFBQUkwRixRQUFRLENBQUNOLE1BQVQsRUFBSixFQUF1QjtBQUNyQixhQUFPLE1BQU05RSxzQkFBc0IsQ0FBQ25CLE9BQUQsRUFBVWlCLFlBQVYsQ0FBbkM7QUFDRCxLQUZELE1BRU87QUFDTCxhQUFPLE1BQU1vQix3QkFBd0IsQ0FBQ3JDLE9BQUQsRUFBVWlCLFlBQVYsQ0FBckM7QUFDRDtBQUNGLEdBZEQsQ0FjRSxPQUFPUCxDQUFQLEVBQVU7QUFDVixRQUFJQSxDQUFDLENBQUN1QixPQUFGLENBQVV5RSxRQUFWLENBQW1COUgsOEJBQW5CLENBQUosRUFBd0Q7QUFDdEQsWUFBTSxJQUFJb0QsS0FBSixDQUFXLFNBQVFuQixVQUFXLGdDQUE5QixDQUFOO0FBQ0Q7O0FBQ0QsVUFBTUgsQ0FBTjtBQUNELEdBbkJELFNBbUJVO0FBQ1JWLElBQUFBLE9BQU8sQ0FBQytGLEtBQVI7QUFDRDtBQUNGOztBQWVELGVBQWVZLG1CQUFmLENBQW9DL0IsTUFBcEMsRUFBNEMvRCxVQUE1QyxFQUF3RDtBQUN0RCxNQUFJb0MsWUFBSjs7QUFDQSxNQUFJM0Usc0JBQXNCLENBQUN3QyxJQUF2QixDQUE0QkQsVUFBNUIsQ0FBSixFQUE2QztBQUMzQyxVQUFNO0FBQUNqQixNQUFBQSxRQUFEO0FBQVdtQixNQUFBQSxlQUFlLEVBQUVpRTtBQUE1QixRQUF1QyxNQUFNaEUsa0JBQWtCLENBQUNILFVBQUQsRUFDbkUsT0FBT29FLFNBQVAsRUFBa0JwRixhQUFsQixLQUFvQyxNQUFNK0UsTUFBTSxDQUFDTSxNQUFQLENBQWNDLGVBQWQsQ0FBOEJGLFNBQTlCLEVBQXlDcEYsYUFBekMsQ0FEeUIsQ0FBckU7O0FBRUFMLG9CQUFJNEYsSUFBSixDQUFVLDZCQUE0QnhGLFFBQVMsV0FBVWlCLFVBQVcsS0FBM0QsR0FDTixJQUFHbUUsT0FBUSxtQkFEZDs7QUFFQS9CLElBQUFBLFlBQVksR0FBRytCLE9BQWY7QUFDRCxHQU5ELE1BTU87QUFDTCxVQUFNa0IsT0FBTyxHQUFHdEIsTUFBTSxDQUFDdUIsTUFBUCxFQUFoQjtBQUNBbEQsSUFBQUEsWUFBWSxHQUFHOUQsY0FBS3VGLEtBQUwsQ0FBV3hELElBQVgsQ0FBZ0JnRixPQUFoQixFQUF5QnJGLFVBQXpCLENBQWY7QUFDQTlCLElBQUFBLGVBQWUsQ0FBQ2tFLFlBQUQsRUFBZWlELE9BQWYsQ0FBZjs7QUFDQTFHLG9CQUFJNEYsSUFBSixDQUFVLHNCQUFxQm5DLFlBQWEsRUFBNUM7QUFDRDs7QUFDRCxNQUFJLEVBQUMsTUFBTUMsa0JBQUdtQyxNQUFILENBQVVwQyxZQUFWLENBQVAsQ0FBSixFQUFvQztBQUNsQ3pELG9CQUFJQyxhQUFKLENBQW1CLHVCQUFzQndELFlBQWEsa0JBQXREO0FBQ0Q7O0FBQ0QsUUFBTUMsa0JBQUdhLE1BQUgsQ0FBVWQsWUFBVixDQUFOO0FBQ0Q7O0FBc0JELGVBQWUyRCxvQkFBZixDQUFxQ2hDLE1BQXJDLEVBQTZDL0QsVUFBN0MsRUFBeUQ7QUFDdkQsUUFBTTtBQUFFYixJQUFBQSxPQUFGO0FBQVdpQixJQUFBQTtBQUFYLE1BQTRCLE1BQU1MLGFBQWEsQ0FBQ2dFLE1BQU0sQ0FBQ2pGLElBQVIsRUFBY2tCLFVBQWQsQ0FBckQ7O0FBQ0EsTUFBSTtBQUNGLFVBQU1iLE9BQU8sQ0FBQzZHLGVBQVIsQ0FBd0I1RixZQUF4QixDQUFOO0FBQ0QsR0FGRCxDQUVFLE9BQU9QLENBQVAsRUFBVTtBQUNWLFFBQUlBLENBQUMsQ0FBQ3VCLE9BQUYsQ0FBVXlFLFFBQVYsQ0FBbUI5SCw4QkFBbkIsQ0FBSixFQUF3RDtBQUN0RCxZQUFNLElBQUlvRCxLQUFKLENBQVcsU0FBUW5CLFVBQVcsZ0NBQTlCLENBQU47QUFDRDs7QUFDRCxVQUFNSCxDQUFOO0FBQ0QsR0FQRCxTQU9VO0FBQ1JWLElBQUFBLE9BQU8sQ0FBQytGLEtBQVI7QUFDRDtBQUNGOztBQVdELGVBQWVlLHFCQUFmLENBQXNDbkgsSUFBdEMsRUFBNEM7QUFDMUMsUUFBTUssT0FBTyxHQUFHLE1BQU1GLDBCQUFTaUgsNkJBQVQsQ0FBdUNwSCxJQUF2QyxDQUF0Qjs7QUFDQSxNQUFJO0FBQ0YsVUFBTXFILFlBQVksR0FBRyxNQUFNaEgsT0FBTyxDQUFDaUgsZ0JBQVIsQ0FBeUI7QUFBQ0MsTUFBQUEsZUFBZSxFQUFFO0FBQWxCLEtBQXpCLENBQTNCO0FBQ0EsVUFBTUMsU0FBUyxHQUFHLEVBQWxCOztBQUNBLFNBQUssTUFBTSxDQUFDQyxHQUFELEVBQU1DLEtBQU4sQ0FBWCxJQUEyQkMsTUFBTSxDQUFDQyxPQUFQLENBQWVQLFlBQWYsQ0FBM0IsRUFBeUQ7QUFDdkQsVUFBSSxDQUFDSyxLQUFLLENBQUNHLG9CQUFYLEVBQWlDO0FBQy9CO0FBQ0Q7O0FBQ0RMLE1BQUFBLFNBQVMsQ0FBQ3JGLElBQVYsQ0FBZXNGLEdBQWY7QUFDRDs7QUFDRCxXQUFPRCxTQUFQO0FBQ0QsR0FWRCxTQVVVO0FBQ1JuSCxJQUFBQSxPQUFPLENBQUMrRixLQUFSO0FBQ0Q7QUFDRjs7QUFHRGpILFFBQVEsQ0FBQzJJLFFBQVQsR0FBb0IsZUFBZUEsUUFBZixDQUF5QjVHLFVBQXpCLEVBQXFDZ0UsVUFBckMsRUFBaUQ7QUFDbkUsTUFBSWhFLFVBQVUsQ0FBQzZHLFFBQVgsQ0FBb0IsR0FBcEIsQ0FBSixFQUE4QjtBQUM1QmxJLG9CQUFJQyxhQUFKLENBQW1CLHdFQUFELEdBQ0MsSUFBR29CLFVBQVcsb0JBRGpDO0FBRUQ7O0FBQ0QsTUFBSVIsZ0JBQUVzSCxPQUFGLENBQVU5QyxVQUFWLENBQUosRUFBMkI7QUFHekJBLElBQUFBLFVBQVUsR0FBRzNDLE1BQU0sQ0FBQzZDLElBQVAsQ0FBWUYsVUFBWixFQUF3QnpDLFFBQXhCLENBQWlDLE1BQWpDLENBQWI7QUFDRDs7QUFDRCxTQUFPLEtBQUt3RixXQUFMLEtBQ0gsTUFBTWpELG1CQUFtQixDQUFDLEtBQUtrRCxJQUFMLENBQVVqRCxNQUFYLEVBQW1CL0QsVUFBbkIsRUFBK0JnRSxVQUEvQixDQUR0QixHQUVILE1BQU1hLG9CQUFvQixDQUFDLEtBQUttQyxJQUFMLENBQVVqRCxNQUFYLEVBQW1CL0QsVUFBbkIsRUFBK0JnRSxVQUEvQixDQUY5QjtBQUdELENBYkQ7O0FBZUEvRixRQUFRLENBQUNnSixRQUFULEdBQW9CLGVBQWVBLFFBQWYsQ0FBeUJqSCxVQUF6QixFQUFxQztBQUN2RCxNQUFJQSxVQUFVLENBQUM2RyxRQUFYLENBQW9CLEdBQXBCLENBQUosRUFBOEI7QUFDNUJsSSxvQkFBSUMsYUFBSixDQUFtQix3RUFBRCxHQUNDLElBQUdvQixVQUFXLG9CQURqQztBQUVEOztBQUNELFNBQU8sS0FBSytHLFdBQUwsS0FDSCxNQUFNNUIsaUJBQWlCLENBQUMsS0FBSzZCLElBQUwsQ0FBVWpELE1BQVgsRUFBbUIvRCxVQUFuQixFQUErQixJQUEvQixDQURwQixHQUVILE1BQU15RixrQkFBa0IsQ0FBQyxLQUFLdUIsSUFBTCxDQUFVakQsTUFBWCxFQUFtQi9ELFVBQW5CLEVBQStCLElBQS9CLENBRjVCO0FBR0QsQ0FSRDs7QUFVQSxlQUFla0gsa0JBQWYsQ0FBbUNuRCxNQUFuQyxFQUEyQy9ELFVBQTNDLEVBQXVEK0csV0FBdkQsRUFBb0U7QUFDbEUsU0FBT0EsV0FBVyxHQUNkLE1BQU1qQixtQkFBbUIsQ0FBQy9CLE1BQUQsRUFBUy9ELFVBQVQsQ0FEWCxHQUVkLE1BQU0rRixvQkFBb0IsQ0FBQ2hDLE1BQUQsRUFBUy9ELFVBQVQsQ0FGOUI7QUFHRDs7QUFFRC9CLFFBQVEsQ0FBQ2tKLGtCQUFULEdBQThCLGVBQWVBLGtCQUFmLENBQW1DSCxJQUFJLEdBQUcsRUFBMUMsRUFBOEM7QUFDMUUsTUFBSTtBQUFDaEgsSUFBQUE7QUFBRCxNQUFlZ0gsSUFBbkI7O0FBQ0EsTUFBSSxDQUFDaEgsVUFBVSxDQUFDNkcsUUFBWCxDQUFvQixHQUFwQixDQUFMLEVBQStCO0FBQzdCN0csSUFBQUEsVUFBVSxHQUFJLEdBQUVBLFVBQVcsR0FBM0I7QUFDRDs7QUFDRCxTQUFPLE1BQU1rSCxrQkFBa0IsQ0FBQyxLQUFLRixJQUFMLENBQVVqRCxNQUFYLEVBQW1CL0QsVUFBbkIsRUFBK0IsS0FBSytHLFdBQUwsRUFBL0IsQ0FBL0I7QUFDRCxDQU5EOztBQVFBOUksUUFBUSxDQUFDbUosZ0JBQVQsR0FBNEIsZUFBZUEsZ0JBQWYsQ0FBaUNKLElBQUksR0FBRyxFQUF4QyxFQUE0QztBQUN0RSxRQUFNO0FBQUNoSCxJQUFBQTtBQUFELE1BQWVnSCxJQUFyQjs7QUFDQSxNQUFJaEgsVUFBVSxDQUFDNkcsUUFBWCxDQUFvQixHQUFwQixDQUFKLEVBQThCO0FBQzVCbEksb0JBQUlDLGFBQUosQ0FBbUIsd0VBQUQsR0FDQyxJQUFHb0IsVUFBVyxvQkFEakM7QUFFRDs7QUFDRCxTQUFPLE1BQU1rSCxrQkFBa0IsQ0FBQyxLQUFLRixJQUFMLENBQVVqRCxNQUFYLEVBQW1CL0QsVUFBbkIsRUFBK0IsS0FBSytHLFdBQUwsRUFBL0IsQ0FBL0I7QUFDRCxDQVBEOztBQVNBOUksUUFBUSxDQUFDb0osa0JBQVQsR0FBOEIsZUFBZUEsa0JBQWYsQ0FBbUNySCxVQUFuQyxFQUErQztBQUMzRSxNQUFJc0gsUUFBUSxHQUFHLEtBQUtOLElBQUwsQ0FBVWpELE1BQVYsQ0FBaUJ1QixNQUFqQixFQUFmO0FBQ0EsTUFBSWlDLE9BQU8sR0FBRyxJQUFkOztBQUVBLE1BQUksS0FBS1AsSUFBTCxDQUFVUSxHQUFkLEVBQW1CO0FBQ2pCLFFBQUlDLFlBQVksR0FBRyxJQUFJL0osTUFBSixDQUFZLEtBQUlZLGNBQUtvSixHQUFJLGlCQUF6QixDQUFuQjtBQUNBLFFBQUlDLGNBQWMsR0FBR0YsWUFBWSxDQUFDcEUsSUFBYixDQUFrQixLQUFLMkQsSUFBTCxDQUFVUSxHQUE1QixDQUFyQjs7QUFDQSxRQUFJRyxjQUFKLEVBQW9CO0FBQ2xCSixNQUFBQSxPQUFPLEdBQUdJLGNBQWMsQ0FBQyxDQUFELENBQXhCO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJQyxzQkFBT0MsU0FBUCxFQUFKLEVBQXdCO0FBQ3RCLFFBQUk3SCxVQUFVLENBQUM4SCxPQUFYLENBQW1CLEtBQW5CLE1BQThCLENBQWxDLEVBQXFDO0FBQ25DOUgsTUFBQUEsVUFBVSxHQUFHQSxVQUFVLENBQUMrSCxLQUFYLENBQWlCLENBQWpCLENBQWI7QUFDRDtBQUNGLEdBSkQsTUFJTztBQUNMLFFBQUkvSCxVQUFVLENBQUN1RCxPQUFYLENBQW1CLEdBQW5CLE1BQTRCLENBQWhDLEVBQW1DO0FBQ2pDdkQsTUFBQUEsVUFBVSxHQUFHQSxVQUFVLENBQUMrSCxLQUFYLENBQWlCLENBQWpCLENBQWI7QUFDRDtBQUNGOztBQUVELE1BQUkvSCxVQUFVLENBQUN0QixVQUFYLENBQXNCNkksT0FBdEIsQ0FBSixFQUFvQztBQUNsQyxRQUFJUyxRQUFRLEdBQUdWLFFBQWY7O0FBQ0EsUUFBSSxDQUFDLEtBQUtOLElBQUwsQ0FBVWlCLGVBQVgsSUFBOEIxQyxvQkFBSzJDLGVBQUwsQ0FBcUIsS0FBS2xCLElBQUwsQ0FBVWlCLGVBQS9CLEVBQWdELElBQWhELEVBQXNELEtBQXRELENBQWxDLEVBQWdHO0FBRTlGRCxNQUFBQSxRQUFRLEdBQUcxSixjQUFLc0MsT0FBTCxDQUFhMEcsUUFBYixFQUF1QixZQUF2QixFQUFxQyxRQUFyQyxDQUFYO0FBQ0Q7O0FBQ0RVLElBQUFBLFFBQVEsR0FBR0EsUUFBUSxDQUFDRyxPQUFULENBQWlCLEtBQWpCLEVBQXdCLEtBQXhCLENBQVg7QUFFQSxRQUFJO0FBQUVDLE1BQUFBO0FBQUYsUUFBYSxNQUFNLHdCQUFLLE1BQUwsRUFBYSxDQUFDSixRQUFELEVBQVcsT0FBWCxFQUFvQlQsT0FBcEIsQ0FBYixDQUF2QjtBQUNBLFFBQUljLE9BQU8sR0FBR0QsTUFBTSxDQUFDRCxPQUFQLENBQWUsS0FBZixFQUFzQixFQUF0QixDQUFkO0FBQ0EsUUFBSUcsT0FBTyxHQUFHdEksVUFBVSxDQUFDd0QsU0FBWCxDQUFxQitELE9BQU8sQ0FBQ3pFLE1BQVIsR0FBaUIsQ0FBdEMsQ0FBZDs7QUFDQSxRQUFJeUYsUUFBUSxHQUFHakssY0FBS3NDLE9BQUwsQ0FBYXlILE9BQWIsRUFBc0JDLE9BQXRCLENBQWY7O0FBQ0EzSixvQkFBSThFLEtBQUosQ0FBVywrQkFBOEI4RSxRQUFTLEdBQWxEOztBQUNBLFdBQU9BLFFBQVA7QUFDRDs7QUFFRCxNQUFJQSxRQUFRLEdBQUdqSyxjQUFLc0MsT0FBTCxDQUFhMEcsUUFBYixFQUF1QnRILFVBQXZCLENBQWY7O0FBQ0FyQixrQkFBSThFLEtBQUosQ0FBVyw4QkFBNkI4RSxRQUFTLEVBQWpEOztBQUNBLFNBQU9BLFFBQVA7QUFDRCxDQXpDRDs7QUEyQ0F0SyxRQUFRLENBQUN1SyxVQUFULEdBQXNCLGVBQWVBLFVBQWYsQ0FBMkJ4SSxVQUEzQixFQUF1QztBQUMzRCxNQUFJLENBQUNBLFVBQVUsQ0FBQzZHLFFBQVgsQ0FBb0IsR0FBcEIsQ0FBTCxFQUErQjtBQUM3QjdHLElBQUFBLFVBQVUsR0FBSSxHQUFFQSxVQUFXLEdBQTNCO0FBQ0Q7O0FBQ0QsU0FBTyxLQUFLK0csV0FBTCxLQUNILE1BQU01QixpQkFBaUIsQ0FBQyxLQUFLNkIsSUFBTCxDQUFVakQsTUFBWCxFQUFtQi9ELFVBQW5CLEVBQStCLEtBQS9CLENBRHBCLEdBRUgsTUFBTXlGLGtCQUFrQixDQUFDLEtBQUt1QixJQUFMLENBQVVqRCxNQUFYLEVBQW1CL0QsVUFBbkIsRUFBK0IsS0FBL0IsQ0FGNUI7QUFHRCxDQVBEOztlQVdlL0IsUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfIGZyb20gJ2xvZGFzaCc7XG5pbXBvcnQgeyBzeXN0ZW0sIGZzLCB0ZW1wRGlyLCBta2RpcnAsIHppcCwgdXRpbCB9IGZyb20gJ2FwcGl1bS1zdXBwb3J0JztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IGxvZyBmcm9tICcuLi9sb2dnZXInO1xuaW1wb3J0IHsgZXhlYyB9IGZyb20gJ3RlZW5fcHJvY2Vzcyc7XG5pbXBvcnQgQiBmcm9tICdibHVlYmlyZCc7XG5pbXBvcnQgeyBzZXJ2aWNlcyB9IGZyb20gJ2FwcGl1bS1pb3MtZGV2aWNlJztcblxuY29uc3QgQ09OVEFJTkVSX1BBVEhfTUFSS0VSID0gJ0AnO1xuLy8gaHR0cHM6Ly9yZWdleDEwMS5jb20vci9QTGRCMEcvMlxuY29uc3QgQ09OVEFJTkVSX1BBVEhfUEFUVEVSTiA9IG5ldyBSZWdFeHAoYF4ke0NPTlRBSU5FUl9QQVRIX01BUktFUn0oW14vXSspLyguKilgKTtcbmNvbnN0IENPTlRBSU5FUl9UWVBFX1NFUEFSQVRPUiA9ICc6JztcbmNvbnN0IElGVVNFX0NPTlRBSU5FUl9ET0NVTUVOVFMgPSAnZG9jdW1lbnRzJztcbmNvbnN0IENPTlRBSU5FUl9ET0NVTUVOVFNfUEFUSCA9ICdEb2N1bWVudHMnO1xuY29uc3QgSU9fVElNRU9VVCA9IDYwMDAwO1xuY29uc3QgT0JKRUNUX05PVF9GT1VORF9FUlJPUl9NRVNTQUdFID0gJ09CSkVDVF9OT1RfRk9VTkQnO1xuY29uc3QgTUFYX1BVTExfQ0hVTktfU0laRSA9IDU7XG5cbmNvbnN0IGNvbW1hbmRzID0ge307XG5cbmZ1bmN0aW9uIHZlcmlmeUlzU3ViUGF0aCAob3JpZ2luYWxQYXRoLCByb290KSB7XG4gIGNvbnN0IG5vcm1hbGl6ZWRSb290ID0gcGF0aC5ub3JtYWxpemUocm9vdCk7XG4gIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gcGF0aC5ub3JtYWxpemUocGF0aC5kaXJuYW1lKG9yaWdpbmFsUGF0aCkpO1xuICAvLyBJZiBvcmlnaW5hbFBhdGggaXMgcm9vdCwgYC9gLCBvcmlnaW5hbFBhdGggc2hvdWxkIGVxdWFsIHRvIG5vcm1hbGl6ZWRSb290XG4gIGlmIChub3JtYWxpemVkUm9vdCAhPT0gb3JpZ2luYWxQYXRoICYmICFub3JtYWxpemVkUGF0aC5zdGFydHNXaXRoKG5vcm1hbGl6ZWRSb290KSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGAnJHtub3JtYWxpemVkUGF0aH0nIGlzIGV4cGVjdGVkIHRvIGJlIGEgc3VicGF0aCBvZiAnJHtub3JtYWxpemVkUm9vdH0nYCk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlQWZjQ2xpZW50ICh1ZGlkLCBidW5kbGVJZCwgY29udGFpbmVyVHlwZSkge1xuICBpZiAoIWJ1bmRsZUlkKSB7XG4gICAgcmV0dXJuIGF3YWl0IHNlcnZpY2VzLnN0YXJ0QWZjU2VydmljZSh1ZGlkKTtcbiAgfVxuICBjb25zdCBzZXJ2aWNlID0gYXdhaXQgc2VydmljZXMuc3RhcnRIb3VzZUFycmVzdFNlcnZpY2UodWRpZCk7XG4gIGlmIChpc0RvY3VtZW50cyhjb250YWluZXJUeXBlKSkge1xuICAgIHJldHVybiBhd2FpdCBzZXJ2aWNlLnZlbmREb2N1bWVudHMoYnVuZGxlSWQpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBhd2FpdCBzZXJ2aWNlLnZlbmRDb250YWluZXIoYnVuZGxlSWQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzRG9jdW1lbnRzIChjb250YWluZXJUeXBlKSB7XG4gIHJldHVybiBfLnRvTG93ZXIoY29udGFpbmVyVHlwZSkgPT09IElGVVNFX0NPTlRBSU5FUl9ET0NVTUVOVFM7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIG1rZGlycERldmljZSAoc2VydmljZSwgZGlyKSB7XG4gIGlmIChkaXIgPT09ICcuJyB8fCBkaXIgPT09ICcvJykge1xuICAgIHJldHVybjtcbiAgfVxuICB0cnkge1xuICAgIGF3YWl0IHNlcnZpY2UubGlzdERpcmVjdG9yeShkaXIpO1xuICAgIHJldHVybjtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRoaXMgbWVhbnMgdGhhdCB0aGUgZGlyZWN0b3J5IGlzIG1pc3NpbmcgYW5kIHdlIGdvdCBhbiBvYmplY3Qgbm90IGZvdW5kIGVycm9yLiBUaGVyZWZvcmUsIHdlIGFyZSBnb2luZyB0byB0aGUgcGFyZW50XG4gICAgYXdhaXQgbWtkaXJwRGV2aWNlKHNlcnZpY2UsIHBhdGguZGlybmFtZShkaXIpKTtcbiAgfVxuICBhd2FpdCBzZXJ2aWNlLmNyZWF0ZURpcmVjdG9yeShkaXIpO1xufVxuXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVTZXJ2aWNlICh1ZGlkLCByZW1vdGVQYXRoKSB7XG4gIGlmIChDT05UQUlORVJfUEFUSF9QQVRURVJOLnRlc3QocmVtb3RlUGF0aCkpIHtcbiAgICBjb25zdCB7YnVuZGxlSWQsIHBhdGhJbkNvbnRhaW5lciwgY29udGFpbmVyVHlwZX0gPSBhd2FpdCBwYXJzZUNvbnRhaW5lclBhdGgocmVtb3RlUGF0aCk7XG4gICAgY29uc3Qgc2VydmljZSA9IGF3YWl0IGNyZWF0ZUFmY0NsaWVudCh1ZGlkLCBidW5kbGVJZCwgY29udGFpbmVyVHlwZSk7XG4gICAgY29uc3QgcmVsYXRpdmVQYXRoID0gaXNEb2N1bWVudHMoY29udGFpbmVyVHlwZSkgPyBwYXRoLmpvaW4oQ09OVEFJTkVSX0RPQ1VNRU5UU19QQVRILCBwYXRoSW5Db250YWluZXIpIDogcGF0aEluQ29udGFpbmVyO1xuICAgIHJldHVybiB7c2VydmljZSwgcmVsYXRpdmVQYXRofTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzZXJ2aWNlID0gYXdhaXQgY3JlYXRlQWZjQ2xpZW50KHVkaWQpO1xuICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IHJlbW90ZVBhdGg7XG4gICAgcmV0dXJuIHtzZXJ2aWNlLCByZWxhdGl2ZVBhdGh9O1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHB1bGxGaWxlRnJvbVJlYWxEZXZpY2UgKHNlcnZpY2UsIHJlbGF0aXZlUGF0aCkge1xuICBjb25zdCBzdHJlYW0gPSBhd2FpdCBzZXJ2aWNlLmNyZWF0ZVJlYWRTdHJlYW0ocmVsYXRpdmVQYXRoLCB7IGF1dG9EZXN0cm95OiB0cnVlIH0pO1xuICBjb25zdCBwdWxsUHJvbWlzZSA9IG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgcmVzb2x2ZSk7XG4gICAgc3RyZWFtLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gIH0pO1xuICBjb25zdCBidWZmZXJzID0gW107XG4gIHN0cmVhbS5vbignZGF0YScsIChkYXRhKSA9PiBidWZmZXJzLnB1c2goZGF0YSkpO1xuICB0cnkge1xuICAgIGF3YWl0IHB1bGxQcm9taXNlLnRpbWVvdXQoSU9fVElNRU9VVCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkbid0IHB1bGwgdGhlIGZpbGUgJyR7cmVsYXRpdmVQYXRofScgYCArXG4gICAgICBgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0ICR7SU9fVElNRU9VVH1tcy4gT3JpZ2luYWwgZXJyb3I6ICR7ZS5tZXNzYWdlfWApO1xuICB9XG4gIHJldHVybiBCdWZmZXIuY29uY2F0KGJ1ZmZlcnMpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gcHVsbEZvbGRlckZyb21SZWFsRGV2aWNlIChzZXJ2aWNlLCByZWxhdGl2ZVBhdGgpIHtcbiAgY29uc3QgdG1wRm9sZGVyID0gYXdhaXQgdGVtcERpci5vcGVuRGlyKCk7XG4gIHRyeSB7XG4gICAgY29uc3QgZm9sZGVyUGF0aCA9IHBhdGguam9pbih0bXBGb2xkZXIsIHJlbGF0aXZlUGF0aCk7XG4gICAgYXdhaXQgbWtkaXJwKGZvbGRlclBhdGgpO1xuICAgIGNvbnN0IHB1bGxQcm9taXNlcyA9IFtdO1xuICAgIGNvbnN0IHdhaXRGb3JQdWxsQ2h1bmtzID0gYXN5bmMgKCkgPT4ge1xuICAgICAgaWYgKF8uaXNFbXB0eShwdWxsUHJvbWlzZXMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgQi5hbGwocHVsbFByb21pc2VzKS50aW1lb3V0KElPX1RJTUVPVVQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkbid0IHB1bGwgYWxsIGl0ZW1zIGluIHRoZSBmb2xkZXIgJyR7cmVsYXRpdmVQYXRofScgYCArXG4gICAgICAgICAgYHdpdGhpbiB0aGUgZ2l2ZW4gdGltZW91dCAke0lPX1RJTUVPVVR9bXMuIE9yaWdpbmFsIGVycm9yOiAke2UubWVzc2FnZX1gKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGF3YWl0IHNlcnZpY2Uud2Fsa0RpcihyZWxhdGl2ZVBhdGgsIHRydWUsIGFzeW5jIChpdGVtUGF0aCwgaXNEaXIpID0+IHtcbiAgICAgIGNvbnN0IHBhdGhPblNlcnZlciA9IHBhdGguam9pbih0bXBGb2xkZXIsIGl0ZW1QYXRoKTtcbiAgICAgIGlmIChpc0Rpcikge1xuICAgICAgICBhd2FpdCBmcy5ta2RpcihwYXRoT25TZXJ2ZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlYWRTdHJlYW0gPSBhd2FpdCBzZXJ2aWNlLmNyZWF0ZVJlYWRTdHJlYW0oaXRlbVBhdGgsIHthdXRvRGVzdHJveTogdHJ1ZX0pO1xuICAgICAgY29uc3Qgd3JpdGVTdHJlYW0gPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShwYXRoT25TZXJ2ZXIsIHthdXRvQ2xvc2U6IHRydWV9KTtcbiAgICAgIHB1bGxQcm9taXNlcy5wdXNoKG5ldyBCKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgd3JpdGVTdHJlYW0ub24oJ2Nsb3NlJywgcmVzb2x2ZSk7XG4gICAgICAgIGNvbnN0IG9uU3RyZWFtaW5nRXJyb3IgPSAoZSkgPT4ge1xuICAgICAgICAgIHJlYWRTdHJlYW0udW5waXBlKHdyaXRlU3RyZWFtKTtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH07XG4gICAgICAgIHdyaXRlU3RyZWFtLm9uKCdlcnJvcicsIG9uU3RyZWFtaW5nRXJyb3IpO1xuICAgICAgICByZWFkU3RyZWFtLm9uKCdlcnJvcicsIG9uU3RyZWFtaW5nRXJyb3IpO1xuICAgICAgfSkpO1xuICAgICAgcmVhZFN0cmVhbS5waXBlKHdyaXRlU3RyZWFtKTtcbiAgICAgIGlmIChwdWxsUHJvbWlzZXMubGVuZ3RoICUgTUFYX1BVTExfQ0hVTktfU0laRSA9PT0gMCkge1xuICAgICAgICBhd2FpdCB3YWl0Rm9yUHVsbENodW5rcygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFdhaXQgZm9yIHRoZSByZXN0IG9mIHRoZSBjaHVua3NcbiAgICBhd2FpdCB3YWl0Rm9yUHVsbENodW5rcygpO1xuICAgIHJldHVybiAoYXdhaXQgemlwLnRvSW5NZW1vcnlaaXAoZm9sZGVyUGF0aCwge1xuICAgICAgZW5jb2RlVG9CYXNlNjQ6IHRydWUsXG4gICAgfSkpLnRvU3RyaW5nKCk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmltcmFmKHRtcEZvbGRlcik7XG4gIH1cbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBDb250YWluZXJPYmplY3RcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYnVuZGxlSWQgLSBUaGUgcGFyc2VkIGJ1bmRsZSBpZGVudGlmaWVyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcGF0aEluQ29udGFpbmVyIC0gVGhlIGFic29sdXRlIGZ1bGwgcGF0aCBvZiB0aGUgaXRlbSBvbiB0aGUgbG9jYWwgZmlsZSBzeXN0ZW1cbiAqIEBwcm9wZXJ0eSB7P3N0cmluZ30gY29udGFpbmVyVHlwZSAtIFRoZSBjb250YWluZXIgdHlwZVxuICovXG5cbi8qKlxuICogUGFyc2VzIHRoZSBhY3R1YWwgcGF0aCBhbmQgdGhlIGJ1bmRsZSBpZGVudGlmaWVyIGZyb20gdGhlIGdpdmVuIHBhdGggc3RyaW5nXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlbW90ZVBhdGggLSBUaGUgZ2l2ZW4gcGF0aCBzdHJpbmcuIFRoZSBzdHJpbmcgc2hvdWxkXG4gKiBtYXRjaCBgQ09OVEFJTkVSX1BBVEhfUEFUVEVSTmAgcmVnZXhwLCBvdGhlcndpc2UgYW4gZXJyb3IgaXMgZ29pbmdcbiAqIHRvIGJlIHRocm93bi4gQSB2YWxpZCBzdHJpbmcgZXhhbXBsZTogYEBidW5kbGUuaWRlbnRpZmllcjpjb250YWluZXJfdHlwZS9yZWxhdGl2ZV9wYXRoX2luX2NvbnRhaW5lcmBcbiAqIEBwYXJhbSB7RnVuY3Rpb258c3RyaW5nfSBjb250YWluZXJSb290U3VwcGxpZXIgLSBFaXRoZXIgYSBzdHJpbmcsIHRoYXQgY29udGFpbnNcbiAqIGZ1bGwgcGF0aCB0byB0aGUgbW91bnQgcm9vdCBmb3IgcmVhbCBkZXZpY2VzIG9yIGEgZnVuY3Rpb24sIHdoaWNoIGFjY2VwdHMgdHdvIHBhcmFtZXRlcnNcbiAqIChidW5kbGUgaWRlbnRpZmllciBhbmQgb3B0aW9uYWwgY29udGFpbmVyIHR5cGUpIGFuZCByZXR1cm5zIGZ1bGwgcGF0aCB0byBjb250YWluZXJcbiAqIHJvb3QgZm9sZGVyIG9uIHRoZSBsb2NhbCBmaWxlIHN5c3RlbSwgZm9yIFNpbXVsYXRvclxuICogQHJldHVybnMge0NvbnRhaW5lck9iamVjdH1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcGFyc2VDb250YWluZXJQYXRoIChyZW1vdGVQYXRoLCBjb250YWluZXJSb290U3VwcGxpZXIpIHtcbiAgY29uc3QgbWF0Y2ggPSBDT05UQUlORVJfUEFUSF9QQVRURVJOLmV4ZWMocmVtb3RlUGF0aCk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgSXQgaXMgZXhwZWN0ZWQgdGhhdCBwYWNrYWdlIGlkZW50aWZpZXIgYCArXG4gICAgICBgc3RhcnRzIHdpdGggJyR7Q09OVEFJTkVSX1BBVEhfTUFSS0VSfScgYW5kIGlzIHNlcGFyYXRlZCBmcm9tIHRoZSBgICtcbiAgICAgIGByZWxhdGl2ZSBwYXRoIHdpdGggYSBzaW5nbGUgc2xhc2guICcke3JlbW90ZVBhdGh9JyBpcyBnaXZlbiBpbnN0ZWFkYCk7XG4gIH1cbiAgbGV0IFssIGJ1bmRsZUlkLCByZWxhdGl2ZVBhdGhdID0gbWF0Y2g7XG4gIGxldCBjb250YWluZXJUeXBlID0gbnVsbDtcbiAgY29uc3QgdHlwZVNlcGFyYXRvclBvcyA9IGJ1bmRsZUlkLmluZGV4T2YoQ09OVEFJTkVSX1RZUEVfU0VQQVJBVE9SKTtcbiAgLy8gV2Ugb25seSBjb25zaWRlciBjb250YWluZXIgdHlwZSBleGlzdHMgaWYgaXRzIGxlbmd0aCBpcyBncmVhdGVyIHRoYW4gemVyb1xuICAvLyBub3QgY291bnRpbmcgdGhlIGNvbG9uXG4gIGlmICh0eXBlU2VwYXJhdG9yUG9zID4gMCAmJiB0eXBlU2VwYXJhdG9yUG9zIDwgYnVuZGxlSWQubGVuZ3RoIC0gMSkge1xuICAgIGNvbnRhaW5lclR5cGUgPSBidW5kbGVJZC5zdWJzdHJpbmcodHlwZVNlcGFyYXRvclBvcyArIDEpO1xuICAgIGxvZy5kZWJ1ZyhgUGFyc2VkIGNvbnRhaW5lciB0eXBlOiAke2NvbnRhaW5lclR5cGV9YCk7XG4gICAgYnVuZGxlSWQgPSBidW5kbGVJZC5zdWJzdHJpbmcoMCwgdHlwZVNlcGFyYXRvclBvcyk7XG4gIH1cbiAgaWYgKF8uaXNOaWwoY29udGFpbmVyUm9vdFN1cHBsaWVyKSkge1xuICAgIGNvbnN0IHBhdGhJbkNvbnRhaW5lciA9IHJlbGF0aXZlUGF0aDtcbiAgICByZXR1cm4geyBidW5kbGVJZCwgcGF0aEluQ29udGFpbmVyLCBjb250YWluZXJUeXBlIH07XG4gIH1cbiAgY29uc3QgY29udGFpbmVyUm9vdCA9IF8uaXNGdW5jdGlvbihjb250YWluZXJSb290U3VwcGxpZXIpXG4gICAgPyBhd2FpdCBjb250YWluZXJSb290U3VwcGxpZXIoYnVuZGxlSWQsIGNvbnRhaW5lclR5cGUpXG4gICAgOiBjb250YWluZXJSb290U3VwcGxpZXI7XG4gIGNvbnN0IHBhdGhJbkNvbnRhaW5lciA9IHBhdGgucG9zaXgucmVzb2x2ZShjb250YWluZXJSb290LCByZWxhdGl2ZVBhdGgpO1xuICB2ZXJpZnlJc1N1YlBhdGgocGF0aEluQ29udGFpbmVyLCBjb250YWluZXJSb290KTtcbiAgcmV0dXJuIHtidW5kbGVJZCwgcGF0aEluQ29udGFpbmVyLCBjb250YWluZXJUeXBlfTtcbn1cblxuLyoqXG4gKiBTYXZlIHRoZSBnaXZlbiBiYXNlNjQgZGF0YSBjaHVuayBhcyBhIGJpbmFyeSBmaWxlIG9uIHRoZSBTaW11bGF0b3IgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBwYXRoIG9uIHRoZSBkZXZpY2UuIFRoaXMgdmFyaWFibGUgY2FuIGJlIHByZWZpeGVkIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVuZGxlIGlkLCBzbyB0aGVuIHRoZSBmaWxlIHdpbGwgYmUgdXBsb2FkZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24gY29udGFpbmVyIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgbWVkaWEgZm9sZGVyLCBmb3IgZXhhbXBsZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnQGNvbS5teWFwcC5ibGE6ZGF0YS9SZWxhdGl2ZVBhdGhJbkNvbnRhaW5lci8xMTEucG5nJy4gVGhlICdAJyBjaGFyYWN0ZXIgYXQgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlZ2lubmluZyBvZiB0aGUgYXJndW1lbnQgaXMgbWFuZGF0b3J5IGluIHN1Y2ggY2FzZS4gVGhlIGNvbG9uIGF0IHRoZSBlbmQgb2YgYnVuZGxlIGlkZW50aWZpZXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgb3B0aW9uYWwgYW5kIGlzIHVzZWQgdG8gZGlzdGluZ3Vpc2ggdGhlIGNvbnRhaW5lciB0eXBlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3NzaWJsZSB2YWx1ZXMgdGhlcmUgYXJlICdhcHAnLCAnZGF0YScsICdncm91cHMnLCAnPEEgc3BlY2lmaWMgQXBwIEdyb3VwIGNvbnRhaW5lcj4nLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAnYXBwJy5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHJlbGF0aXZlIGZvbGRlciBwYXRoIGlzIGlnbm9yZWQgaWYgdGhlIGZpbGUgaXMgZ29pbmcgdG8gYmUgdXBsb2FkZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gdGhlIGRlZmF1bHQgbWVkaWEgZm9sZGVyIGFuZCBvbmx5IHRoZSBmaWxlIG5hbWUgaXMgY29uc2lkZXJlZCBpbXBvcnRhbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0RGF0YSAtIEJhc2UtNjQgZW5jb2RlZCBjb250ZW50IG9mIHRoZSBmaWxlIHRvIGJlIHVwbG9hZGVkLlxuICovXG5hc3luYyBmdW5jdGlvbiBwdXNoRmlsZVRvU2ltdWxhdG9yIChkZXZpY2UsIHJlbW90ZVBhdGgsIGJhc2U2NERhdGEpIHtcbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oYmFzZTY0RGF0YSwgJ2Jhc2U2NCcpO1xuICBpZiAoQ09OVEFJTkVSX1BBVEhfUEFUVEVSTi50ZXN0KHJlbW90ZVBhdGgpKSB7XG4gICAgY29uc3Qge2J1bmRsZUlkLCBwYXRoSW5Db250YWluZXI6IGRzdFBhdGh9ID0gYXdhaXQgcGFyc2VDb250YWluZXJQYXRoKHJlbW90ZVBhdGgsXG4gICAgICBhc3luYyAoYXBwQnVuZGxlLCBjb250YWluZXJUeXBlKSA9PiBhd2FpdCBkZXZpY2Uuc2ltY3RsLmdldEFwcENvbnRhaW5lcihhcHBCdW5kbGUsIGNvbnRhaW5lclR5cGUpKTtcbiAgICBsb2cuaW5mbyhgUGFyc2VkIGJ1bmRsZSBpZGVudGlmaWVyICcke2J1bmRsZUlkfScgZnJvbSAnJHtyZW1vdGVQYXRofScuIGAgK1xuICAgICAgYFdpbGwgcHV0IHRoZSBkYXRhIGludG8gJyR7ZHN0UGF0aH0nYCk7XG4gICAgaWYgKCFhd2FpdCBmcy5leGlzdHMocGF0aC5kaXJuYW1lKGRzdFBhdGgpKSkge1xuICAgICAgbG9nLmRlYnVnKGBUaGUgZGVzdGluYXRpb24gZm9sZGVyICcke3BhdGguZGlybmFtZShkc3RQYXRoKX0nIGRvZXMgbm90IGV4aXN0LiBDcmVhdGluZy4uLmApO1xuICAgICAgYXdhaXQgbWtkaXJwKHBhdGguZGlybmFtZShkc3RQYXRoKSk7XG4gICAgfVxuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RQYXRoLCBidWZmZXIpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBkc3RGb2xkZXIgPSBhd2FpdCB0ZW1wRGlyLm9wZW5EaXIoKTtcbiAgY29uc3QgZHN0UGF0aCA9IHBhdGgucmVzb2x2ZShkc3RGb2xkZXIsIHBhdGguYmFzZW5hbWUocmVtb3RlUGF0aCkpO1xuICB0cnkge1xuICAgIGF3YWl0IGZzLndyaXRlRmlsZShkc3RQYXRoLCBidWZmZXIpO1xuICAgIGF3YWl0IGRldmljZS5zaW1jdGwuYWRkTWVkaWEoZHN0UGF0aCk7XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgZnMucmltcmFmKGRzdEZvbGRlcik7XG4gIH1cbn1cblxuLyoqXG4gKiBTYXZlIHRoZSBnaXZlbiBiYXNlNjQgZGF0YSBjaHVuayBhcyBhIGJpbmFyeSBmaWxlIG9uIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHJlbW90ZSBwYXRoIG9uIHRoZSBkZXZpY2UuIFRoaXMgdmFyaWFibGUgY2FuIGJlIHByZWZpeGVkIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVuZGxlIGlkLCBzbyB0aGVuIHRoZSBmaWxlIHdpbGwgYmUgdXBsb2FkZWQgdG8gdGhlIGNvcnJlc3BvbmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24gY29udGFpbmVyIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgbWVkaWEgZm9sZGVyLiBVc2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQDxhcHBfYnVuZGxlX2lkPjo8b3B0aW9uYWxfY29udGFpbmVyX3R5cGU+LzxwYXRoX3RvX3RoZV9maWxlX29yX2ZvbGRlcl9pbnNpZGVfY29udGFpbmVyPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQgdG8gcHVsbCBhIGZpbGUgb3IgYSBmb2xkZXIgZnJvbSBhbiBhcHBsaWNhdGlvbiBjb250YWluZXIgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvbmx5IHN1cHBvcnRlZCBjb250YWluZXIgdHlwZSBpcyAnZG9jdW1lbnRzJy4gSWYgdGhlIGNvbnRhaW5lciB0eXBlIGlzIG5vdCBzZXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwbGljaXRseSBmb3IgYSBidW5kbGUgaWQsIHRoZW4gdGhlIGRlZmF1bHQgYXBwbGljYXRpb24gY29udGFpbmVyIGlzIGdvaW5nIHRvIGJlIG1vdW50ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFrYSAtLWNvbnRhaW5lciBpZnVzZSBhcmd1bWVudClcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5nLiBJZiBgQGNvbS5teWFwcC5ibGE6ZG9jdW1lbnRzLzExMS5wbmdgIGlzIHByb3ZpZGVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPmAgaW4gRmlsZXMgYXBwIHdpbGwgYmUgbW91bnRlZCBpbiB0aGUgaG9zdCBtYWNoaW5lLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEJhc2U2NCBlbmNvZGVkIGAxMTEucG5nYCB3aWxsIGJlIHB1c2hlZCBpbnRvIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPi8xMTEucG5nYFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzIGJhc2U2NCBkZWNvZGVkIGRhdGEuXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0RGF0YSAtIEJhc2UtNjQgZW5jb2RlZCBjb250ZW50IG9mIHRoZSBmaWxlIHRvIGJlIHVwbG9hZGVkLlxuICovXG5hc3luYyBmdW5jdGlvbiBwdXNoRmlsZVRvUmVhbERldmljZSAoZGV2aWNlLCByZW1vdGVQYXRoLCBiYXNlNjREYXRhKSB7XG4gIGNvbnN0IHtzZXJ2aWNlLCByZWxhdGl2ZVBhdGh9ID0gYXdhaXQgY3JlYXRlU2VydmljZShkZXZpY2UudWRpZCwgcmVtb3RlUGF0aCk7XG4gIHRyeSB7XG4gICAgYXdhaXQgbWtkaXJwRGV2aWNlKHNlcnZpY2UsIHBhdGguZGlybmFtZShyZWxhdGl2ZVBhdGgpKTtcbiAgICBjb25zdCBzdHJlYW0gPSBhd2FpdCBzZXJ2aWNlLmNyZWF0ZVdyaXRlU3RyZWFtKHJlbGF0aXZlUGF0aCwge2F1dG9EZXN0cm95OiB0cnVlfSk7XG4gICAgbGV0IHB1c2hFcnJvciA9IG51bGw7XG4gICAgY29uc3QgcHVzaFByb21pc2UgPSBuZXcgQigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBzdHJlYW0ub24oJ2Vycm9yJywgKGUpID0+IHtcbiAgICAgICAgcHVzaEVycm9yID0gZTtcbiAgICAgIH0pO1xuICAgICAgc3RyZWFtLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgaWYgKHB1c2hFcnJvcikge1xuICAgICAgICAgIHJlamVjdChwdXNoRXJyb3IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgc3RyZWFtLndyaXRlKEJ1ZmZlci5mcm9tKGJhc2U2NERhdGEsICdiYXNlNjQnKSk7XG4gICAgc3RyZWFtLmVuZCgpO1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBwdXNoUHJvbWlzZS50aW1lb3V0KElPX1RJTUVPVVQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IHB1c2ggdGhlIGZpbGUgd2l0aGluIHRoZSBnaXZlbiB0aW1lb3V0ICR7SU9fVElNRU9VVH1tcy4gYCArXG4gICAgICAgIGBPcmlnaW5hbCBlcnJvcjogJHtlLm1lc3NhZ2V9YCk7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHNlcnZpY2UuY2xvc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgY29udGVudCBvZiBnaXZlbiBmaWxlIG9yIGZvbGRlciBmcm9tIGlPUyBTaW11bGF0b3IgYW5kIHJldHVybiBpdCBhcyBiYXNlLTY0IGVuY29kZWQgc3RyaW5nLlxuICogRm9sZGVyIGNvbnRlbnQgaXMgcmVjdXJzaXZlbHkgcGFja2VkIGludG8gYSB6aXAgYXJjaGl2ZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHBhdGggdG8gYSBmaWxlIG9yIGEgZm9sZGVyLCB3aGljaCBleGlzdHMgaW4gdGhlIGNvcnJlc3BvbmRpbmcgYXBwbGljYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyIG9uIFNpbXVsYXRvci4gVXNlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEA8YXBwX2J1bmRsZV9pZD46PG9wdGlvbmFsX2NvbnRhaW5lcl90eXBlPi88cGF0aF90b190aGVfZmlsZV9vcl9mb2xkZXJfaW5zaWRlX2NvbnRhaW5lcj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0IHRvIHB1bGwgYSBmaWxlIG9yIGEgZm9sZGVyIGZyb20gYW4gYXBwbGljYXRpb24gY29udGFpbmVyIG9mIHRoZSBnaXZlbiB0eXBlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3NzaWJsZSBjb250YWluZXIgdHlwZXMgYXJlICdhcHAnLCAnZGF0YScsICdncm91cHMnLCAnPEEgc3BlY2lmaWMgQXBwIEdyb3VwIGNvbnRhaW5lcj4nLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCB0eXBlIGlzICdhcHAnLlxuICogQHBhcmFtIHtib29sZWFufSBpc0ZpbGUgLSBXaGV0aGVyIHRoZSBkZXN0aW5hdGlvbiBpdGVtIGlzIGEgZmlsZSBvciBhIGZvbGRlclxuICogQHJldHVybnMge3N0cmluZ30gQmFzZS02NCBlbmNvZGVkIGNvbnRlbnQgb2YgdGhlIGZpbGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHB1bGxGcm9tU2ltdWxhdG9yIChkZXZpY2UsIHJlbW90ZVBhdGgsIGlzRmlsZSkge1xuICBsZXQgcGF0aE9uU2VydmVyO1xuICBpZiAoQ09OVEFJTkVSX1BBVEhfUEFUVEVSTi50ZXN0KHJlbW90ZVBhdGgpKSB7XG4gICAgY29uc3Qge2J1bmRsZUlkLCBwYXRoSW5Db250YWluZXI6IGRzdFBhdGh9ID0gYXdhaXQgcGFyc2VDb250YWluZXJQYXRoKHJlbW90ZVBhdGgsXG4gICAgICBhc3luYyAoYXBwQnVuZGxlLCBjb250YWluZXJUeXBlKSA9PiBhd2FpdCBkZXZpY2Uuc2ltY3RsLmdldEFwcENvbnRhaW5lcihhcHBCdW5kbGUsIGNvbnRhaW5lclR5cGUpKTtcbiAgICBsb2cuaW5mbyhgUGFyc2VkIGJ1bmRsZSBpZGVudGlmaWVyICcke2J1bmRsZUlkfScgZnJvbSAnJHtyZW1vdGVQYXRofScuIGAgK1xuICAgICAgYFdpbGwgZ2V0IHRoZSBkYXRhIGZyb20gJyR7ZHN0UGF0aH0nYCk7XG4gICAgcGF0aE9uU2VydmVyID0gZHN0UGF0aDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzaW1Sb290ID0gZGV2aWNlLmdldERpcigpO1xuICAgIHBhdGhPblNlcnZlciA9IHBhdGgucG9zaXguam9pbihzaW1Sb290LCByZW1vdGVQYXRoKTtcbiAgICB2ZXJpZnlJc1N1YlBhdGgocGF0aE9uU2VydmVyLCBzaW1Sb290KTtcbiAgICBsb2cuaW5mbyhgR290IHRoZSBmdWxsIGl0ZW0gcGF0aDogJHtwYXRoT25TZXJ2ZXJ9YCk7XG4gIH1cbiAgaWYgKCFhd2FpdCBmcy5leGlzdHMocGF0aE9uU2VydmVyKSkge1xuICAgIGxvZy5lcnJvckFuZFRocm93KGBUaGUgcmVtb3RlICR7aXNGaWxlID8gJ2ZpbGUnIDogJ2ZvbGRlcid9IGF0ICcke3BhdGhPblNlcnZlcn0nIGRvZXMgbm90IGV4aXN0YCk7XG4gIH1cbiAgY29uc3QgYnVmZmVyID0gaXNGaWxlXG4gICAgPyBhd2FpdCB1dGlsLnRvSW5NZW1vcnlCYXNlNjQocGF0aE9uU2VydmVyKVxuICAgIDogYXdhaXQgemlwLnRvSW5NZW1vcnlaaXAocGF0aE9uU2VydmVyLCB7ZW5jb2RlVG9CYXNlNjQ6IHRydWV9KTtcbiAgcmV0dXJuIGJ1ZmZlci50b1N0cmluZygpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgY29udGVudCBvZiBnaXZlbiBmaWxlIG9yIGZvbGRlciBmcm9tIHRoZSByZWFsIGRldmljZSB1bmRlciB0ZXN0IGFuZCByZXR1cm4gaXQgYXMgYmFzZS02NCBlbmNvZGVkIHN0cmluZy5cbiAqIEZvbGRlciBjb250ZW50IGlzIHJlY3Vyc2l2ZWx5IHBhY2tlZCBpbnRvIGEgemlwIGFyY2hpdmUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRldmljZSAtIFRoZSBkZXZpY2Ugb2JqZWN0LCB3aGljaCByZXByZXNlbnRzIHRoZSBkZXZpY2UgdW5kZXIgdGVzdC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGlzIG9iamVjdCBpcyBleHBlY3RlZCB0byBoYXZlIHRoZSBgdWRpZGAgcHJvcGVydHkgY29udGFpbmluZyB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxpZCBkZXZpY2UgSUQuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVtb3RlUGF0aCAtIFRoZSBwYXRoIHRvIGFuIGV4aXN0aW5nIHJlbW90ZSBmaWxlIG9uIHRoZSBkZXZpY2UuIFRoaXMgdmFyaWFibGUgY2FuIGJlIHByZWZpeGVkIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnVuZGxlIGlkLCBzbyB0aGVuIHRoZSBmaWxlIHdpbGwgYmUgZG93bmxvYWRlZCBmcm9tIHRoZSBjb3JyZXNwb25kaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGxpY2F0aW9uIGNvbnRhaW5lciBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IG1lZGlhIGZvbGRlci4gVXNlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEA8YXBwX2J1bmRsZV9pZD46PG9wdGlvbmFsX2NvbnRhaW5lcl90eXBlPi88cGF0aF90b190aGVfZmlsZV9vcl9mb2xkZXJfaW5zaWRlX2NvbnRhaW5lcj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0IHRvIHB1bGwgYSBmaWxlIG9yIGEgZm9sZGVyIGZyb20gYW4gYXBwbGljYXRpb24gY29udGFpbmVyIG9mIHRoZSBnaXZlbiB0eXBlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgb25seSBzdXBwb3J0ZWQgY29udGFpbmVyIHR5cGUgaXMgJ2RvY3VtZW50cycuIElmIHRoZSBjb250YWluZXIgdHlwZSBpcyBub3Qgc2V0XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4cGxpY2l0bHkgZm9yIGEgYnVuZGxlIGlkLCB0aGVuIHRoZSBkZWZhdWx0IGFwcGxpY2F0aW9uIGNvbnRhaW5lciBpcyBnb2luZyB0byBiZSBtb3VudGVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChha2EgLS1jb250YWluZXIgaWZ1c2UgYXJndW1lbnQpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuZy4gSWYgYEBjb20ubXlhcHAuYmxhOmRvY3VtZW50cy8xMTEucG5nYCBpcyBwcm92aWRlZCxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgT24gTXkgaVBob25lLzxhcHAgbmFtZT5gIGluIEZpbGVzIGFwcCB3aWxsIGJlIG1vdW50ZWQgaW4gdGhlIGhvc3QgbWFjaGluZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgT24gTXkgaVBob25lLzxhcHAgbmFtZT4vMTExLnBuZ2Agd2lsIGJlIHB1bGxlZCBpbnRvIHRoZSBtb3VudGVkIGhvc3QgbWFjaGluZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZCBBcHBpdW0gcmV0dXJucyB0aGUgZGF0YSBhcyBiYXNlNjQtZW5jb2RlZCBzdHJpbmcgdG8gY2xpZW50LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBAY29tLm15YXBwLmJsYTpkb2N1bWVudHMvYCBtZWFucyBgT24gTXkgaVBob25lLzxhcHAgbmFtZT5gLlxuICogQHBhcmFtIHtib29sZWFufSBpc0ZpbGUgLSBXaGV0aGVyIHRoZSBkZXN0aW5hdGlvbiBpdGVtIGlzIGEgZmlsZSBvciBhIGZvbGRlclxuICogQHJldHVybiB7c3RyaW5nfSBCYXNlLTY0IGVuY29kZWQgY29udGVudCBvZiB0aGUgcmVtb3RlIGZpbGVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gcHVsbEZyb21SZWFsRGV2aWNlIChkZXZpY2UsIHJlbW90ZVBhdGgsIGlzRmlsZSkge1xuICBjb25zdCB7c2VydmljZSwgcmVsYXRpdmVQYXRofSA9IGF3YWl0IGNyZWF0ZVNlcnZpY2UoZGV2aWNlLnVkaWQsIHJlbW90ZVBhdGgpO1xuICB0cnkge1xuICAgIGNvbnN0IGZpbGVJbmZvID0gYXdhaXQgc2VydmljZS5nZXRGaWxlSW5mbyhyZWxhdGl2ZVBhdGgpO1xuICAgIGlmIChpc0ZpbGUgJiYgZmlsZUluZm8uaXNEaXJlY3RvcnkoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgcmVxdWVzdGVkIHBhdGggaXMgbm90IGEgZmlsZS4gUGF0aDogJyR7cmVtb3RlUGF0aH0nYCk7XG4gICAgfVxuICAgIGlmICghaXNGaWxlICYmICFmaWxlSW5mby5pc0RpcmVjdG9yeSgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSByZXF1ZXN0ZWQgcGF0aCBpcyBub3QgYSBmb2xkZXIuIFBhdGg6ICcke3JlbW90ZVBhdGh9J2ApO1xuICAgIH1cblxuICAgIGlmIChmaWxlSW5mby5pc0ZpbGUoKSkge1xuICAgICAgcmV0dXJuIGF3YWl0IHB1bGxGaWxlRnJvbVJlYWxEZXZpY2Uoc2VydmljZSwgcmVsYXRpdmVQYXRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGF3YWl0IHB1bGxGb2xkZXJGcm9tUmVhbERldmljZShzZXJ2aWNlLCByZWxhdGl2ZVBhdGgpO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmIChlLm1lc3NhZ2UuaW5jbHVkZXMoT0JKRUNUX05PVF9GT1VORF9FUlJPUl9NRVNTQUdFKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXRoICcke3JlbW90ZVBhdGh9JyBkb2VzIG5vdCBleGlzdCBvbiB0aGUgZGV2aWNlYCk7XG4gICAgfVxuICAgIHRocm93IGU7XG4gIH0gZmluYWxseSB7XG4gICAgc2VydmljZS5jbG9zZSgpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBmaWxlIG9yIGZvbGRlciBmcm9tIHRoZSBkZXZpY2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHBhdGggdG8gYSBmaWxlIG9yIGEgZm9sZGVyLCB3aGljaCBleGlzdHMgaW4gdGhlIGNvcnJlc3BvbmRpbmcgYXBwbGljYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyIG9uIFNpbXVsYXRvci4gVXNlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEA8YXBwX2J1bmRsZV9pZD46PG9wdGlvbmFsX2NvbnRhaW5lcl90eXBlPi88cGF0aF90b190aGVfZmlsZV9vcl9mb2xkZXJfaW5zaWRlX2NvbnRhaW5lcj5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybWF0IHRvIHB1bGwgYSBmaWxlIG9yIGEgZm9sZGVyIGZyb20gYW4gYXBwbGljYXRpb24gY29udGFpbmVyIG9mIHRoZSBnaXZlbiB0eXBlLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBQb3NzaWJsZSBjb250YWluZXIgdHlwZXMgYXJlICdhcHAnLCAnZGF0YScsICdncm91cHMnLCAnPEEgc3BlY2lmaWMgQXBwIEdyb3VwIGNvbnRhaW5lcj4nLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgZGVmYXVsdCB0eXBlIGlzICdhcHAnLlxuICovXG5hc3luYyBmdW5jdGlvbiBkZWxldGVGcm9tU2ltdWxhdG9yIChkZXZpY2UsIHJlbW90ZVBhdGgpIHtcbiAgbGV0IHBhdGhPblNlcnZlcjtcbiAgaWYgKENPTlRBSU5FUl9QQVRIX1BBVFRFUk4udGVzdChyZW1vdGVQYXRoKSkge1xuICAgIGNvbnN0IHtidW5kbGVJZCwgcGF0aEluQ29udGFpbmVyOiBkc3RQYXRofSA9IGF3YWl0IHBhcnNlQ29udGFpbmVyUGF0aChyZW1vdGVQYXRoLFxuICAgICAgYXN5bmMgKGFwcEJ1bmRsZSwgY29udGFpbmVyVHlwZSkgPT4gYXdhaXQgZGV2aWNlLnNpbWN0bC5nZXRBcHBDb250YWluZXIoYXBwQnVuZGxlLCBjb250YWluZXJUeXBlKSk7XG4gICAgbG9nLmluZm8oYFBhcnNlZCBidW5kbGUgaWRlbnRpZmllciAnJHtidW5kbGVJZH0nIGZyb20gJyR7cmVtb3RlUGF0aH0nLiBgICtcbiAgICAgIGAnJHtkc3RQYXRofScgd2lsbCBiZSBkZWxldGVkYCk7XG4gICAgcGF0aE9uU2VydmVyID0gZHN0UGF0aDtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBzaW1Sb290ID0gZGV2aWNlLmdldERpcigpO1xuICAgIHBhdGhPblNlcnZlciA9IHBhdGgucG9zaXguam9pbihzaW1Sb290LCByZW1vdGVQYXRoKTtcbiAgICB2ZXJpZnlJc1N1YlBhdGgocGF0aE9uU2VydmVyLCBzaW1Sb290KTtcbiAgICBsb2cuaW5mbyhgR290IHRoZSBmdWxsIHBhdGg6ICR7cGF0aE9uU2VydmVyfWApO1xuICB9XG4gIGlmICghYXdhaXQgZnMuZXhpc3RzKHBhdGhPblNlcnZlcikpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgVGhlIHJlbW90ZSBwYXRoIGF0ICcke3BhdGhPblNlcnZlcn0nIGRvZXMgbm90IGV4aXN0YCk7XG4gIH1cbiAgYXdhaXQgZnMucmltcmFmKHBhdGhPblNlcnZlcik7XG59XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBmaWxlIG9yIGZvbGRlciBmcm9tIHRoZSBkZXZpY2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGV2aWNlIC0gVGhlIGRldmljZSBvYmplY3QsIHdoaWNoIHJlcHJlc2VudHMgdGhlIGRldmljZSB1bmRlciB0ZXN0LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIFRoaXMgb2JqZWN0IGlzIGV4cGVjdGVkIHRvIGhhdmUgdGhlIGB1ZGlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkIGRldmljZSBJRC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByZW1vdGVQYXRoIC0gVGhlIHBhdGggdG8gYW4gZXhpc3RpbmcgcmVtb3RlIGZpbGUgb24gdGhlIGRldmljZS4gVGhpcyB2YXJpYWJsZSBjYW4gYmUgcHJlZml4ZWQgd2l0aFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidW5kbGUgaWQsIHNvIHRoZW4gdGhlIGZpbGUgd2lsbCBiZSBkb3dubG9hZGVkIGZyb20gdGhlIGNvcnJlc3BvbmRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwbGljYXRpb24gY29udGFpbmVyIGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgbWVkaWEgZm9sZGVyLiBVc2VcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQDxhcHBfYnVuZGxlX2lkPjo8b3B0aW9uYWxfY29udGFpbmVyX3R5cGU+LzxwYXRoX3RvX3RoZV9maWxlX29yX2ZvbGRlcl9pbnNpZGVfY29udGFpbmVyPlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQgdG8gcHVsbCBhIGZpbGUgb3IgYSBmb2xkZXIgZnJvbSBhbiBhcHBsaWNhdGlvbiBjb250YWluZXIgb2YgdGhlIGdpdmVuIHR5cGUuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBvbmx5IHN1cHBvcnRlZCBjb250YWluZXIgdHlwZSBpcyAnZG9jdW1lbnRzJy4gSWYgdGhlIGNvbnRhaW5lciB0eXBlIGlzIG5vdCBzZXRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwbGljaXRseSBmb3IgYSBidW5kbGUgaWQsIHRoZW4gdGhlIGRlZmF1bHQgYXBwbGljYXRpb24gY29udGFpbmVyIGlzIGdvaW5nIHRvIGJlIG1vdW50ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGFrYSAtLWNvbnRhaW5lciBpZnVzZSBhcmd1bWVudClcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZS5nLiBJZiBgQGNvbS5teWFwcC5ibGE6ZG9jdW1lbnRzLzExMS5wbmdgIGlzIHByb3ZpZGVkLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPmAgaW4gRmlsZXMgYXBwIHdpbGwgYmUgbW91bnRlZCBpbiB0aGUgaG9zdCBtYWNoaW5lLlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPi8xMTEucG5nYCB3aWwgYmUgcHVsbGVkIGludG8gdGhlIG1vdW50ZWQgaG9zdCBtYWNoaW5lXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5kIEFwcGl1bSByZXR1cm5zIHRoZSBkYXRhIGFzIGJhc2U2NC1lbmNvZGVkIHN0cmluZyB0byBjbGllbnQuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYEBjb20ubXlhcHAuYmxhOmRvY3VtZW50cy9gIG1lYW5zIGBPbiBNeSBpUGhvbmUvPGFwcCBuYW1lPmAuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUZyb21SZWFsRGV2aWNlIChkZXZpY2UsIHJlbW90ZVBhdGgpIHtcbiAgY29uc3QgeyBzZXJ2aWNlLCByZWxhdGl2ZVBhdGggfSA9IGF3YWl0IGNyZWF0ZVNlcnZpY2UoZGV2aWNlLnVkaWQsIHJlbW90ZVBhdGgpO1xuICB0cnkge1xuICAgIGF3YWl0IHNlcnZpY2UuZGVsZXRlRGlyZWN0b3J5KHJlbGF0aXZlUGF0aCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBpZiAoZS5tZXNzYWdlLmluY2x1ZGVzKE9CSkVDVF9OT1RfRk9VTkRfRVJST1JfTUVTU0FHRSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUGF0aCAnJHtyZW1vdGVQYXRofScgZG9lcyBub3QgZXhpc3Qgb24gdGhlIGRldmljZWApO1xuICAgIH1cbiAgICB0aHJvdyBlO1xuICB9IGZpbmFsbHkge1xuICAgIHNlcnZpY2UuY2xvc2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIEdldCBidW5kbGVJZHMgd2hpY2ggY2FuIG1vdW50IGJ5IGAtLWRvY3VtZW50c2AgZmxhZ1xuICpcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdWRpZCAtIFRoZSB1ZGlkIG9mIHRoZSB0YXJnZXQgZGV2aWNlXG4gKiBAcmV0dXJucyB7QXJyYXk8c3RyaW5nPn0gQSBsaXN0IG9mIFVzZXIgbGV2ZWwgYXBwcycgYnVuZGxlIGlkcyB3aGljaCBoYXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAnVUlGaWxlU2hhcmluZ0VuYWJsZWQnIGF0dHJpYnV0ZS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBPbmx5IHVzZXIgYXBwcyBtaWdodCBoYXZlIGl0LlxuICovXG5hc3luYyBmdW5jdGlvbiBnZXRBdmFpbGFibGVCdW5kbGVJZHMgKHVkaWQpIHtcbiAgY29uc3Qgc2VydmljZSA9IGF3YWl0IHNlcnZpY2VzLnN0YXJ0SW5zdGFsbGF0aW9uUHJveHlTZXJ2aWNlKHVkaWQpO1xuICB0cnkge1xuICAgIGNvbnN0IGFwcGxpY2F0aW9ucyA9IGF3YWl0IHNlcnZpY2UubGlzdEFwcGxpY2F0aW9ucyh7YXBwbGljYXRpb25UeXBlOiAnVXNlcid9KTtcbiAgICBjb25zdCBidW5kbGVJZHMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhcHBsaWNhdGlvbnMpKSB7XG4gICAgICBpZiAoIXZhbHVlLlVJRmlsZVNoYXJpbmdFbmFibGVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgYnVuZGxlSWRzLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1bmRsZUlkcztcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXJ2aWNlLmNsb3NlKCk7XG4gIH1cbn1cblxuXG5jb21tYW5kcy5wdXNoRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIHB1c2hGaWxlIChyZW1vdGVQYXRoLCBiYXNlNjREYXRhKSB7XG4gIGlmIChyZW1vdGVQYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgSXQgaXMgZXhwZWN0ZWQgdGhhdCByZW1vdGUgcGF0aCBwb2ludHMgdG8gYSBmaWxlIGFuZCBub3QgdG8gYSBmb2xkZXIuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGAnJHtyZW1vdGVQYXRofScgaXMgZ2l2ZW4gaW5zdGVhZGApO1xuICB9XG4gIGlmIChfLmlzQXJyYXkoYmFzZTY0RGF0YSkpIHtcbiAgICAvLyBzb21lIGNsaWVudHMgKGFoZW0pIGphdmEsIHNlbmQgYSBieXRlIGFycmF5IGVuY29kaW5nIHV0ZjggY2hhcmFjdGVyc1xuICAgIC8vIGluc3RlYWQgb2YgYSBzdHJpbmcsIHdoaWNoIHdvdWxkIGJlIGluZmluaXRlbHkgYmV0dGVyIVxuICAgIGJhc2U2NERhdGEgPSBCdWZmZXIuZnJvbShiYXNlNjREYXRhKS50b1N0cmluZygndXRmOCcpO1xuICB9XG4gIHJldHVybiB0aGlzLmlzU2ltdWxhdG9yKClcbiAgICA/IGF3YWl0IHB1c2hGaWxlVG9TaW11bGF0b3IodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgYmFzZTY0RGF0YSlcbiAgICA6IGF3YWl0IHB1c2hGaWxlVG9SZWFsRGV2aWNlKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIGJhc2U2NERhdGEpO1xufTtcblxuY29tbWFuZHMucHVsbEZpbGUgPSBhc3luYyBmdW5jdGlvbiBwdWxsRmlsZSAocmVtb3RlUGF0aCkge1xuICBpZiAocmVtb3RlUGF0aC5lbmRzV2l0aCgnLycpKSB7XG4gICAgbG9nLmVycm9yQW5kVGhyb3coYEl0IGlzIGV4cGVjdGVkIHRoYXQgcmVtb3RlIHBhdGggcG9pbnRzIHRvIGEgZmlsZSBhbmQgbm90IHRvIGEgZm9sZGVyLiBgICtcbiAgICAgICAgICAgICAgICAgICAgICBgJyR7cmVtb3RlUGF0aH0nIGlzIGdpdmVuIGluc3RlYWRgKTtcbiAgfVxuICByZXR1cm4gdGhpcy5pc1NpbXVsYXRvcigpXG4gICAgPyBhd2FpdCBwdWxsRnJvbVNpbXVsYXRvcih0aGlzLm9wdHMuZGV2aWNlLCByZW1vdGVQYXRoLCB0cnVlKVxuICAgIDogYXdhaXQgcHVsbEZyb21SZWFsRGV2aWNlKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIHRydWUpO1xufTtcblxuYXN5bmMgZnVuY3Rpb24gZGVsZXRlRmlsZU9yRm9sZGVyIChkZXZpY2UsIHJlbW90ZVBhdGgsIGlzU2ltdWxhdG9yKSB7XG4gIHJldHVybiBpc1NpbXVsYXRvclxuICAgID8gYXdhaXQgZGVsZXRlRnJvbVNpbXVsYXRvcihkZXZpY2UsIHJlbW90ZVBhdGgpXG4gICAgOiBhd2FpdCBkZWxldGVGcm9tUmVhbERldmljZShkZXZpY2UsIHJlbW90ZVBhdGgpO1xufVxuXG5jb21tYW5kcy5tb2JpbGVEZWxldGVGb2xkZXIgPSBhc3luYyBmdW5jdGlvbiBtb2JpbGVEZWxldGVGb2xkZXIgKG9wdHMgPSB7fSkge1xuICBsZXQge3JlbW90ZVBhdGh9ID0gb3B0cztcbiAgaWYgKCFyZW1vdGVQYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICByZW1vdGVQYXRoID0gYCR7cmVtb3RlUGF0aH0vYDtcbiAgfVxuICByZXR1cm4gYXdhaXQgZGVsZXRlRmlsZU9yRm9sZGVyKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIHRoaXMuaXNTaW11bGF0b3IoKSk7XG59O1xuXG5jb21tYW5kcy5tb2JpbGVEZWxldGVGaWxlID0gYXN5bmMgZnVuY3Rpb24gbW9iaWxlRGVsZXRlRmlsZSAob3B0cyA9IHt9KSB7XG4gIGNvbnN0IHtyZW1vdGVQYXRofSA9IG9wdHM7XG4gIGlmIChyZW1vdGVQYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICBsb2cuZXJyb3JBbmRUaHJvdyhgSXQgaXMgZXhwZWN0ZWQgdGhhdCByZW1vdGUgcGF0aCBwb2ludHMgdG8gYSBmaWxlIGFuZCBub3QgdG8gYSBmb2xkZXIuIGAgK1xuICAgICAgICAgICAgICAgICAgICAgIGAnJHtyZW1vdGVQYXRofScgaXMgZ2l2ZW4gaW5zdGVhZGApO1xuICB9XG4gIHJldHVybiBhd2FpdCBkZWxldGVGaWxlT3JGb2xkZXIodGhpcy5vcHRzLmRldmljZSwgcmVtb3RlUGF0aCwgdGhpcy5pc1NpbXVsYXRvcigpKTtcbn07XG5cbmNvbW1hbmRzLmdldFNpbUZpbGVGdWxsUGF0aCA9IGFzeW5jIGZ1bmN0aW9uIGdldFNpbUZpbGVGdWxsUGF0aCAocmVtb3RlUGF0aCkge1xuICBsZXQgYmFzZVBhdGggPSB0aGlzLm9wdHMuZGV2aWNlLmdldERpcigpO1xuICBsZXQgYXBwTmFtZSA9IG51bGw7XG5cbiAgaWYgKHRoaXMub3B0cy5hcHApIHtcbiAgICBsZXQgYXBwTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cChgXFxcXCR7cGF0aC5zZXB9KFtcXFxcdy1dK1xcXFwuYXBwKWApO1xuICAgIGxldCBhcHBOYW1lTWF0Y2hlcyA9IGFwcE5hbWVSZWdleC5leGVjKHRoaXMub3B0cy5hcHApO1xuICAgIGlmIChhcHBOYW1lTWF0Y2hlcykge1xuICAgICAgYXBwTmFtZSA9IGFwcE5hbWVNYXRjaGVzWzFdO1xuICAgIH1cbiAgfVxuICAvLyBkZS1hYnNvbHV0aXplIHRoZSBwYXRoXG4gIGlmIChzeXN0ZW0uaXNXaW5kb3dzKCkpIHtcbiAgICBpZiAocmVtb3RlUGF0aC5pbmRleG9mKCc6Ly8nKSA9PT0gMSkge1xuICAgICAgcmVtb3RlUGF0aCA9IHJlbW90ZVBhdGguc2xpY2UoNCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChyZW1vdGVQYXRoLmluZGV4T2YoJy8nKSA9PT0gMCkge1xuICAgICAgcmVtb3RlUGF0aCA9IHJlbW90ZVBhdGguc2xpY2UoMSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlbW90ZVBhdGguc3RhcnRzV2l0aChhcHBOYW1lKSkge1xuICAgIGxldCBmaW5kUGF0aCA9IGJhc2VQYXRoO1xuICAgIGlmICghdGhpcy5vcHRzLnBsYXRmb3JtVmVyc2lvbiB8fCB1dGlsLmNvbXBhcmVWZXJzaW9ucyh0aGlzLm9wdHMucGxhdGZvcm1WZXJzaW9uLCAnPj0nLCAnOC4wJykpIHtcbiAgICAgIC8vIHRoZSAuYXBwIGZpbGUgYXBwZWFycyBpbiAvQ29udGFpbmVycy9EYXRhIGFuZCAvQ29udGFpbmVycy9CdW5kbGUgYm90aC4gV2Ugb25seSB3YW50IC9CdW5kbGVcbiAgICAgIGZpbmRQYXRoID0gcGF0aC5yZXNvbHZlKGJhc2VQYXRoLCAnQ29udGFpbmVycycsICdCdW5kbGUnKTtcbiAgICB9XG4gICAgZmluZFBhdGggPSBmaW5kUGF0aC5yZXBsYWNlKC9cXHMvZywgJ1xcXFwgJyk7XG5cbiAgICBsZXQgeyBzdGRvdXQgfSA9IGF3YWl0IGV4ZWMoJ2ZpbmQnLCBbZmluZFBhdGgsICctbmFtZScsIGFwcE5hbWVdKTtcbiAgICBsZXQgYXBwUm9vdCA9IHN0ZG91dC5yZXBsYWNlKC9cXG4kLywgJycpO1xuICAgIGxldCBzdWJQYXRoID0gcmVtb3RlUGF0aC5zdWJzdHJpbmcoYXBwTmFtZS5sZW5ndGggKyAxKTtcbiAgICBsZXQgZnVsbFBhdGggPSBwYXRoLnJlc29sdmUoYXBwUm9vdCwgc3ViUGF0aCk7XG4gICAgbG9nLmRlYnVnKGBGaW5kaW5nIGFwcC1yZWxhdGl2ZSBmaWxlOiAnJHtmdWxsUGF0aH0nYCk7XG4gICAgcmV0dXJuIGZ1bGxQYXRoO1xuICB9XG5cbiAgbGV0IGZ1bGxQYXRoID0gcGF0aC5yZXNvbHZlKGJhc2VQYXRoLCByZW1vdGVQYXRoKTtcbiAgbG9nLmRlYnVnKGBGaW5kaW5nIHNpbS1yZWxhdGl2ZSBmaWxlOiAke2Z1bGxQYXRofWApO1xuICByZXR1cm4gZnVsbFBhdGg7XG59O1xuXG5jb21tYW5kcy5wdWxsRm9sZGVyID0gYXN5bmMgZnVuY3Rpb24gcHVsbEZvbGRlciAocmVtb3RlUGF0aCkge1xuICBpZiAoIXJlbW90ZVBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgIHJlbW90ZVBhdGggPSBgJHtyZW1vdGVQYXRofS9gO1xuICB9XG4gIHJldHVybiB0aGlzLmlzU2ltdWxhdG9yKClcbiAgICA/IGF3YWl0IHB1bGxGcm9tU2ltdWxhdG9yKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIGZhbHNlKVxuICAgIDogYXdhaXQgcHVsbEZyb21SZWFsRGV2aWNlKHRoaXMub3B0cy5kZXZpY2UsIHJlbW90ZVBhdGgsIGZhbHNlKTtcbn07XG5cbmV4cG9ydCB7IGNvbW1hbmRzLCAvKiBmb3IgdGVzdGluZyAqLyBnZXRBdmFpbGFibGVCdW5kbGVJZHMsXG4gIC8qIGZvciB0ZXN0aW5nICovIHBhcnNlQ29udGFpbmVyUGF0aCB9O1xuZXhwb3J0IGRlZmF1bHQgY29tbWFuZHM7XG4iXSwiZmlsZSI6ImxpYi9jb21tYW5kcy9maWxlLW1vdmVtZW50LmpzIiwic291cmNlUm9vdCI6Ii4uLy4uLy4uIn0=
